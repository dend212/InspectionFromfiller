---
phase: 04-review-workflow
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/(dashboard)/review/page.tsx
  - src/app/(dashboard)/review/[id]/page.tsx
  - src/components/review/review-editor.tsx
  - src/components/review/review-section.tsx
  - src/components/review/review-actions.tsx
  - src/components/review/return-dialog.tsx
  - src/components/ui/collapsible.tsx
  - src/app/(dashboard)/inspections/[id]/inspection-pdf-view.tsx
  - src/app/(dashboard)/inspections/page.tsx
  - src/lib/email/send-notification.ts
  - src/app/api/notifications/settings/route.ts
  - src/app/api/inspections/[id]/submit/route.ts
autonomous: true
requirements:
  - WKFL-02

user_setup:
  - service: resend
    why: "Email notification for submitted inspections"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
      - name: ADMIN_NOTIFICATION_EMAIL
        source: "Dan's email address for receiving notifications"
    dashboard_config:
      - task: "Create free Resend account and generate API key"
        location: "https://resend.com -> Sign up -> API Keys"
      - task: "Add RESEND_API_KEY and ADMIN_NOTIFICATION_EMAIL to Vercel environment variables"
        location: "Vercel Dashboard -> Project -> Settings -> Environment Variables"

must_haves:
  truths:
    - "Dan can see a list of submitted inspections awaiting review at /review"
    - "Dan can open a submitted inspection and see all field data alongside a PDF preview"
    - "Dan can edit ANY field (summaries, recommendations, and all field data) in the review interface"
    - "Dan can click Regenerate PDF to see updated PDF after edits"
    - "Dan can download the current PDF at any point during review"
    - "Dan can finalize an inspection, locking it from further edits"
    - "Dan can return an inspection to the field tech with a note"
    - "Dan can reopen a finalized inspection for further edits"
    - "Finalized inspections display a clear completed status badge and are read-only for field techs"
    - "Dan can toggle email notifications for new submissions"
  artifacts:
    - path: "src/app/(dashboard)/review/page.tsx"
      provides: "Review queue listing page showing in_review inspections"
      contains: "Review Queue"
    - path: "src/app/(dashboard)/review/[id]/page.tsx"
      provides: "Server component loading inspection data for review editor"
      contains: "ReviewEditor"
    - path: "src/components/review/review-editor.tsx"
      provides: "Side-by-side layout: editable form sections left, PDF preview right"
      contains: "grid-cols-1 lg:grid-cols-2"
    - path: "src/components/review/review-section.tsx"
      provides: "Collapsible form section for review interface"
      contains: "Collapsible"
    - path: "src/components/review/review-actions.tsx"
      provides: "Finalize, Return, Reopen action buttons"
      contains: "Finalize"
    - path: "src/components/review/return-dialog.tsx"
      provides: "Dialog for entering return note when sending back to field tech"
      contains: "return"
    - path: "src/lib/email/send-notification.ts"
      provides: "Resend email sending utility"
      contains: "resend"
  key_links:
    - from: "src/app/(dashboard)/review/[id]/page.tsx"
      to: "src/components/review/review-editor.tsx"
      via: "Server component passes inspection data to client editor"
      pattern: "ReviewEditor"
    - from: "src/components/review/review-editor.tsx"
      to: "/api/inspections/[id]"
      via: "PATCH to save edited field data"
      pattern: "fetch.*PATCH"
    - from: "src/components/review/review-editor.tsx"
      to: "src/hooks/use-pdf-generation.ts"
      via: "usePdfGeneration hook for regenerate"
      pattern: "usePdfGeneration"
    - from: "src/components/review/review-actions.tsx"
      to: "/api/inspections/[id]/finalize"
      via: "POST to finalize inspection"
      pattern: "fetch.*finalize"
    - from: "src/components/review/return-dialog.tsx"
      to: "/api/inspections/[id]/return"
      via: "POST with note to return to field tech"
      pattern: "fetch.*return"
---

<objective>
Review queue page, side-by-side review editor with collapsible form sections and PDF preview, action buttons (finalize, return, reopen), return-note dialog, email notification on submission, and notification settings. Also updates the inspection detail and list pages for status-aware behavior.

Purpose: Give Dan (admin/office staff) a complete review workflow where he can see submitted inspections, edit any field data, preview and regenerate PDFs, and finalize or return reports. Completes the review loop from submission to finalization.

Output: Review queue page, review editor page, 5 review components, email notification utility, notification settings API
</objective>

<execution_context>
@/Users/danielendres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielendres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-review-workflow/04-RESEARCH.md
@.planning/phases/04-review-workflow/04-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase + Plan 04-01 outputs. -->

From src/lib/db/schema.ts (after Plan 04-01):
```typescript
export const inspections = pgTable("inspections", {
  id: uuid("id").defaultRandom().primaryKey(),
  inspectorId: uuid("inspector_id").references(() => profiles.id).notNull(),
  status: inspectionStatusEnum("status").default("draft").notNull(),
  facilityName: text("facility_name"),
  facilityAddress: text("facility_address"),
  facilityCity: text("facility_city"),
  facilityCounty: text("facility_county"),
  facilityState: varchar("facility_state", { length: 2 }).default("AZ"),
  facilityZip: varchar("facility_zip", { length: 10 }),
  formData: jsonb("form_data"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  submittedAt: timestamp("submitted_at"),
  completedAt: timestamp("completed_at"),
  reviewNotes: text("review_notes"),
  finalizedPdfPath: text("finalized_pdf_path"),
  reviewedBy: uuid("reviewed_by").references(() => profiles.id),
});

export const profiles = pgTable("profiles", {
  // ... existing fields ...
  notificationSettings: jsonb("notification_settings").default({ emailOnSubmission: false }),
});
```

From src/hooks/use-pdf-generation.ts:
```typescript
export function usePdfGeneration(): {
  generatePdf: (formData: InspectionFormData, signatureDataUrl: string | null, media?: MediaRecord[]) => Promise<void>;
  pdfData: Uint8Array | null;
  isGenerating: boolean;
  error: string | null;
  clearPdf: () => void;
}
```

From src/components/inspection/pdf-preview.tsx:
```typescript
interface PdfPreviewProps {
  pdfData: Uint8Array | null;
  facilityName?: string;
}
export function PdfPreview({ pdfData, facilityName }: PdfPreviewProps) { ... }
```

From src/types/inspection.ts:
```typescript
export type InspectionFormData = z.infer<typeof inspectionFormSchema>;
```

From src/lib/validators/inspection.ts:
```typescript
export const facilityInfoSchema = z.object({ ... });
export const generalTreatmentSchema = z.object({ ... });
export const designFlowSchema = z.object({ ... });
export const septicTankSchema = z.object({ ... });
export const disposalWorksSchema = z.object({ ... });
export const inspectionFormSchema = z.object({
  facilityInfo: facilityInfoSchema,
  generalTreatment: generalTreatmentSchema,
  designFlow: designFlowSchema,
  septicTank: septicTankSchema,
  disposalWorks: disposalWorksSchema,
});
export const STEP_FIELDS: Record<number, string[]> = { ... };
export function getDefaultFormValues(inspectorName: string): InspectionFormData;
```

From src/lib/constants/inspection.ts:
```typescript
export const STEP_LABELS: string[] = [
  "Facility Information",
  "General Treatment",
  "Design Flow",
  "Septic Tank Inspection",
  "Disposal Works",
];
```

From src/components/inspection/media-gallery.tsx:
```typescript
export interface MediaRecord {
  id: string;
  type: "photo" | "video";
  storagePath: string;
  label: string | null;
  sortOrder: number | null;
  createdAt: string;
}
```

From src/types/roles.ts:
```typescript
export type AppRole = "admin" | "field_tech" | "office_staff";
```

Status transition API endpoints (from Plan 04-01):
```
POST /api/inspections/[id]/submit   -> draft -> in_review
POST /api/inspections/[id]/return   -> in_review -> draft (body: { note })
POST /api/inspections/[id]/finalize -> in_review -> completed (body: { pdfPath? })
POST /api/inspections/[id]/reopen   -> completed -> in_review
PATCH /api/inspections/[id]         -> save formData (field techs: draft only; admin: any status)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Review queue page and collapsible section component</name>
  <files>
    src/app/(dashboard)/review/page.tsx
    src/components/review/review-section.tsx
    src/components/ui/collapsible.tsx
  </files>
  <action>
**Install shadcn Collapsible component:**
```bash
npx shadcn@latest add collapsible
```
This creates `src/components/ui/collapsible.tsx`.

**Create review queue page (src/app/(dashboard)/review/page.tsx):**

A server component that:
1. Authenticates user and checks role (admin or office_staff required -- redirect non-privileged users to `/`)
2. Use the same `getUserRole` pattern as existing pages (JWT decode from session)
3. Queries inspections with status `"in_review"` ordered by `submittedAt` descending (most recent first), joining with profiles to get inspector name:

```typescript
const reviewQueue = await db
  .select({
    id: inspections.id,
    facilityName: inspections.facilityName,
    facilityAddress: inspections.facilityAddress,
    facilityCity: inspections.facilityCity,
    facilityCounty: inspections.facilityCounty,
    submittedAt: inspections.submittedAt,
    inspectorId: inspections.inspectorId,
  })
  .from(inspections)
  .where(eq(inspections.status, "in_review"))
  .orderBy(desc(inspections.submittedAt));
```

Optionally also query completed inspections for a secondary section (show "Recently Completed" below the main queue).

4. Renders a page titled "Review Queue" with:
   - Count of in_review inspections
   - Card grid (same style as inspections list page) linking to `/review/{id}` for each
   - Each card shows: facility name, address/city, submitted date, inspector name (from profiles join or just show "Submitted" date)
   - Status badge (use same STATUS_LABELS and STATUS_COLORS patterns from inspections page)
   - Empty state with "No inspections awaiting review" message and ClipboardCheck icon

5. Optionally: Show a "Completed" section below with recently completed inspections (last 10) linking to `/review/{id}` for reference.

**Create ReviewSection component (src/components/review/review-section.tsx):**

A client component wrapping shadcn Collapsible for the review editor:

```typescript
"use client";

import { useState } from "react";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { Card, CardHeader, CardTitle } from "@/components/ui/card";
import { ChevronDown, ChevronRight } from "lucide-react";

interface ReviewSectionProps {
  title: string;
  defaultOpen?: boolean;
  children: React.ReactNode;
}
```

Renders a Card with:
- CardHeader as CollapsibleTrigger with chevron icon (rotates on open/close)
- CollapsibleContent wrapping CardContent with the children
- `defaultOpen` defaults to `true` for the first section
- Cursor pointer on header, smooth transition
  </action>
  <verify>
    <automated>cd "/Users/danielendres/Documents/Dans Stuff/Inspection Form Filler" && npx tsc --noEmit 2>&1 | tail -5 && ls src/app/\(dashboard\)/review/page.tsx src/components/review/review-section.tsx src/components/ui/collapsible.tsx</automated>
  </verify>
  <done>
    - Review queue page exists at /review showing in_review inspections
    - Page requires admin or office_staff role (redirects others)
    - Inspections displayed as cards linking to /review/[id]
    - ReviewSection component wraps shadcn Collapsible with card styling
    - Collapsible component installed
    - No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Side-by-side review editor with PDF preview, regenerate, and all action buttons</name>
  <files>
    src/app/(dashboard)/review/[id]/page.tsx
    src/components/review/review-editor.tsx
    src/components/review/review-actions.tsx
    src/components/review/return-dialog.tsx
    src/app/(dashboard)/inspections/[id]/inspection-pdf-view.tsx
    src/app/(dashboard)/inspections/page.tsx
  </files>
  <action>
**Create review detail page (src/app/(dashboard)/review/[id]/page.tsx):**

Server component that:
1. Authenticates user and checks admin/office_staff role (same pattern as other protected pages)
2. Loads inspection by ID with all fields (same query pattern as inspection detail page)
3. Loads media records for the inspection
4. If inspection not found, redirect to `/review`
5. Passes all data to the ReviewEditor client component:

```typescript
<ReviewEditor
  inspection={{
    id: inspection.id,
    status: inspection.status,
    formData: inspection.formData as InspectionFormData | null,
    facilityName: inspection.facilityName,
    facilityAddress: inspection.facilityAddress,
    facilityCity: inspection.facilityCity,
    facilityCounty: inspection.facilityCounty,
    createdAt: inspection.createdAt.toISOString(),
    reviewNotes: inspection.reviewNotes,
  }}
  media={media.map(m => ({
    id: m.id,
    type: m.type as "photo" | "video",
    storagePath: m.storagePath,
    label: m.label,
    sortOrder: m.sortOrder,
    createdAt: m.createdAt.toISOString(),
  }))}
/>
```

**Create ReviewEditor component (src/components/review/review-editor.tsx):**

A large client component with:

1. **State management:** Use `react-hook-form` with `zodResolver(inspectionFormSchema)` (same as wizard, with `as any` cast for Zod v4). Initialize with `inspection.formData ?? getDefaultFormValues("")`.

2. **PDF generation:** Use `usePdfGeneration()` hook. Provide a "Regenerate PDF" button that calls `generatePdf(form.getValues(), null, media)`. When any field is edited (detect via `form.formState.isDirty`), show a hint text "Form data changed -- regenerate PDF to see updates" and clear the current PDF preview.

3. **Layout (side-by-side):**
```tsx
<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
  {/* Left panel: scrollable form sections */}
  <div className="space-y-4">
    {/* Action bar at top */}
    <ReviewActions ... />

    {/* 5 collapsible sections */}
    <ReviewSection title="Facility Information" defaultOpen>
      {/* Form fields using FormField + FormItem pattern from wizard */}
    </ReviewSection>
    <ReviewSection title="General Treatment">...</ReviewSection>
    <ReviewSection title="Design Flow">...</ReviewSection>
    <ReviewSection title="Septic Tank Inspection">...</ReviewSection>
    <ReviewSection title="Disposal Works">...</ReviewSection>

    {/* Save button */}
    <Button onClick={handleSave} disabled={saving}>
      {saving ? <Loader2 className="animate-spin" /> : null}
      Save Changes
    </Button>
  </div>

  {/* Right panel: sticky PDF preview */}
  <div className="lg:sticky lg:top-20 lg:self-start space-y-4">
    <Card>
      <CardContent className="pt-6 space-y-4">
        <Button onClick={handleRegenerate} disabled={isGenerating} className="w-full">
          {isGenerating ? <Loader2 className="animate-spin" /> : <RefreshCw />}
          Regenerate PDF
        </Button>
        {pdfData && <PdfPreview pdfData={pdfData} facilityName={form.watch("facilityInfo.facilityName")} />}
      </CardContent>
    </Card>
  </div>
</div>
```

4. **Form fields within each ReviewSection:** Reuse the same field rendering pattern as the wizard steps, but use simpler Input/Textarea/Checkbox components directly (not the full step components, which are tightly coupled to the wizard). For each section, render the fields using `FormField` + `FormItem` + `FormLabel` + `FormControl` from shadcn/ui form:

For Facility Info: facilityName, facilityAddress, facilityCity, facilityCounty, facilityState, facilityZip, taxParcelNumber, dateOfInspection, sellerName, inspectorName, company, certificationNumber, registrationNumber, truckNumber (key fields only -- don't need every qualification checkbox, just the editable text fields and key checkboxes).

**Important simplification:** Rather than re-implementing all 100+ form fields from the wizard steps, focus on the EDITABLE fields Dan would actually want to change in review:
- Section 1 (Facility Info): All property, seller, and inspector text fields
- Section 2 (General Treatment): systemTypes array (as text display -- rarely edited in review)
- Section 3 (Design Flow): designFlow, actualFlow, flowEvaluation
- Section 4 (Septic Tank): Per-tank condition fields, deficiency checkboxes
- Section 5 (Disposal Works): Summary fields (`inspectorSummary`, `overallCondition`, `recommendations`), deficiency checkboxes

For fields that Dan rarely edits (like inspector qualifications, records obtained), render them as read-only display text within the section. Use a "Show All Fields" toggle within each section to reveal the less-common fields if needed.

The summary and recommendation fields in Section 5 are the PRIMARY fields Dan edits. Make these prominent:
- `inspectorSummary`: large Textarea
- `overallCondition`: select or text field
- `recommendations`: large Textarea

5. **Save handler:** On "Save Changes" click:
```typescript
const handleSave = async () => {
  setSaving(true);
  try {
    const data = form.getValues();
    const res = await fetch(`/api/inspections/${inspection.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
    if (!res.ok) throw new Error((await res.json()).error);
    toast.success("Changes saved");
  } catch (err) {
    toast.error(err instanceof Error ? err.message : "Failed to save");
  } finally {
    setSaving(false);
  }
};
```

6. **Status-aware read-only:** If `inspection.status === "completed"`, disable all form fields and hide the Save/Regenerate buttons. Show a green "Completed" badge prominently. Admin can still click "Reopen" (via ReviewActions) to re-enable editing.

**Create ReviewActions component (src/components/review/review-actions.tsx):**

Client component showing status-dependent action buttons:

Props:
```typescript
interface ReviewActionsProps {
  inspectionId: string;
  status: string;
  onStatusChange: (newStatus: string) => void;
}
```

Renders:
- Status badge (large, prominent)
- When status is `"in_review"`:
  - "Finalize Report" button (green, primary) -- calls POST `/api/inspections/[id]/finalize`. On success, calls `onStatusChange("completed")` and shows success toast.
  - "Return to Tech" button (outline, amber) -- opens ReturnDialog
- When status is `"completed"`:
  - "Reopen for Editing" button (outline) -- calls POST `/api/inspections/[id]/reopen`. On success, calls `onStatusChange("in_review")` and shows success toast.
  - "Completed" badge prominently displayed

Each button shows a confirmation AlertDialog before executing the action. Use the AlertDialog from Plan 04-01.

**Create ReturnDialog component (src/components/review/return-dialog.tsx):**

Client component:
```typescript
interface ReturnDialogProps {
  inspectionId: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onReturned: () => void;
}
```

Uses AlertDialog (or Dialog for a form) with:
- Title: "Return to Field Tech"
- Textarea for the return note (placeholder: "Explain what needs to be fixed...")
- Cancel and "Return Inspection" buttons
- On confirm: POST `/api/inspections/[id]/return` with `{ note }` body
- On success: toast.success, call onReturned, close dialog
- On error: toast.error

**Update InspectionPdfView (inspection-pdf-view.tsx):**

Add status-aware behavior for field techs viewing completed inspections:
- When `status === "completed"`, hide the "Edit" button link
- Add a green "Completed" badge styling (already has badge, just ensure `completed` variant looks clearly finalized -- use `bg-emerald-100 text-emerald-800` or a distinct green)
- When `status === "in_review"`, hide the "Edit" button and show text "This inspection is under review"

**Update inspections list page (inspections/page.tsx):**

Currently all inspection cards link to `/inspections/[id]/edit`. Update the link logic:
- For field techs (`!isPrivileged`):
  - Draft inspections: link to `/inspections/[id]/edit` (existing behavior)
  - In-review/completed inspections: link to `/inspections/[id]` (read-only detail view)
- For admin/office_staff:
  - Draft inspections: link to `/inspections/[id]/edit`
  - In-review/completed inspections: link to `/review/[id]` (review interface)

This requires the card's `href` to be conditional based on `isPrivileged` and `inspection.status`.
  </action>
  <verify>
    <automated>cd "/Users/danielendres/Documents/Dans Stuff/Inspection Form Filler" && npx tsc --noEmit 2>&1 | tail -10 && ls src/app/\(dashboard\)/review/\[id\]/page.tsx src/components/review/review-editor.tsx src/components/review/review-actions.tsx src/components/review/return-dialog.tsx</automated>
  </verify>
  <done>
    - Review editor page loads inspection data and renders side-by-side layout
    - Left panel: 5 collapsible form sections with editable fields via react-hook-form
    - Right panel: sticky PDF preview with Regenerate button using usePdfGeneration hook
    - Save Changes button PATCHes form data to existing API
    - ReviewActions shows Finalize/Return buttons for in_review, Reopen for completed
    - ReturnDialog accepts a note and POSTs to /api/inspections/[id]/return
    - Completed inspections are read-only in the review editor
    - InspectionPdfView hides Edit for non-draft statuses
    - Inspections list page links field techs to read-only view for non-drafts
    - No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Email notification on submission and notification settings API</name>
  <files>
    src/lib/email/send-notification.ts
    src/app/api/notifications/settings/route.ts
    src/app/api/inspections/[id]/submit/route.ts
  </files>
  <action>
**Install Resend:**
```bash
npm install resend
```

**Create email notification utility (src/lib/email/send-notification.ts):**

```typescript
import { Resend } from "resend";

const resend = process.env.RESEND_API_KEY
  ? new Resend(process.env.RESEND_API_KEY)
  : null;

export async function sendSubmissionNotification(
  inspectionId: string,
  facilityName: string | null,
  inspectorName: string | null
) {
  const adminEmail = process.env.ADMIN_NOTIFICATION_EMAIL;
  if (!resend || !adminEmail) {
    console.log("Email notification skipped: RESEND_API_KEY or ADMIN_NOTIFICATION_EMAIL not configured");
    return;
  }

  try {
    await resend.emails.send({
      from: "SewerTime Inspections <onboarding@resend.dev>", // Use Resend test sender until domain verified
      to: adminEmail,
      subject: `New Inspection Submitted: ${facilityName || "Untitled"}`,
      text: [
        "A new inspection has been submitted for review.",
        "",
        `Facility: ${facilityName || "Untitled"}`,
        inspectorName ? `Inspector: ${inspectorName}` : "",
        "",
        `Review it here: ${process.env.NEXT_PUBLIC_APP_URL || "https://sewertime.vercel.app"}/review/${inspectionId}`,
      ].filter(Boolean).join("\n"),
    });
  } catch (err) {
    // Fire-and-forget: log but don't throw
    console.error("Failed to send submission notification:", err);
  }
}
```

Note: Use `onboarding@resend.dev` as the from address until Dan verifies a custom domain. This works for Resend's test mode.

**Create notification settings API (src/app/api/notifications/settings/route.ts):**

GET: Return the current user's notification settings from the profiles table.
```typescript
// Auth check, then:
const [profile] = await db
  .select({ notificationSettings: profiles.notificationSettings })
  .from(profiles)
  .where(eq(profiles.id, user.id))
  .limit(1);

return NextResponse.json(profile?.notificationSettings ?? { emailOnSubmission: false });
```

PUT: Update the current user's notification settings.
```typescript
const settings = await request.json();
await db
  .update(profiles)
  .set({ notificationSettings: settings, updatedAt: new Date() })
  .where(eq(profiles.id, user.id));

return NextResponse.json(settings);
```

Import: `createClient` from `@/lib/supabase/server`, `db` from `@/lib/db`, `profiles` from `@/lib/db/schema`, `eq` from `drizzle-orm`.

**Modify submit route (src/app/api/inspections/[id]/submit/route.ts):**

After the successful status transition (after the atomic update returns a row), add fire-and-forget email notification:

```typescript
// After successful submission update...

// Fire-and-forget email notification
import { sendSubmissionNotification } from "@/lib/email/send-notification";
import { db as dbClient } from "@/lib/db";
import { profiles } from "@/lib/db/schema";

// Check if admin has email notifications enabled
// Query admin profiles with notification_settings.emailOnSubmission = true
// For simplicity, just check if the env vars are set and send
// The notification preference check is a nice-to-have -- for v1, just send if configured
sendSubmissionNotification(
  id,
  updated.facilityName ?? null,
  null // inspector name could be fetched but not critical
).catch(console.error);
```

Actually, to properly check the admin's notification preference:

```typescript
// After successful update, check admin notification settings
const admins = await db
  .select({
    notificationSettings: profiles.notificationSettings,
  })
  .from(profiles)
  .innerJoin(userRoles, eq(userRoles.userId, profiles.id))
  .where(eq(userRoles.role, "admin"));

const adminWantsEmail = admins.some(
  (a) => (a.notificationSettings as any)?.emailOnSubmission === true
);

if (adminWantsEmail) {
  // Get facility name from the updated inspection
  const [inspectionData] = await db
    .select({ facilityName: inspections.facilityName })
    .from(inspections)
    .where(eq(inspections.id, id))
    .limit(1);

  sendSubmissionNotification(
    id,
    inspectionData?.facilityName ?? null,
    null
  ).catch(console.error);
}
```

Import `userRoles` from schema. Import `sendSubmissionNotification` from `@/lib/email/send-notification`. Also update the submit route's `.returning()` clause to include `facilityName`:

```typescript
.returning({ id: inspections.id, facilityName: inspections.facilityName });
```

Then use `updated.facilityName` directly instead of a separate query.
  </action>
  <verify>
    <automated>cd "/Users/danielendres/Documents/Dans Stuff/Inspection Form Filler" && npx tsc --noEmit 2>&1 | tail -5 && ls src/lib/email/send-notification.ts src/app/api/notifications/settings/route.ts && grep -c "sendSubmissionNotification" src/app/api/inspections/\[id\]/submit/route.ts</automated>
  </verify>
  <done>
    - Resend package installed
    - sendSubmissionNotification utility sends email to admin when env vars configured
    - Notification settings API (GET/PUT) reads/writes notificationSettings on profiles
    - Submit route fires notification after successful submission (only if admin opted in)
    - Email sending is fire-and-forget (does not block the response)
    - Gracefully degrades when RESEND_API_KEY not configured (logs and skips)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Review queue page at /review lists in_review inspections (admin/office_staff only)
3. Review editor at /review/[id] shows side-by-side layout with form sections and PDF preview
4. Collapsible sections expand/collapse with smooth animation
5. Save Changes PATCHes form data and shows success toast
6. Regenerate PDF uses existing usePdfGeneration hook and updates preview
7. Finalize button calls /api/inspections/[id]/finalize and transitions to completed
8. Return button opens dialog, sends note, transitions to draft
9. Reopen button on completed inspections transitions back to in_review
10. Completed inspections are read-only in review editor
11. InspectionPdfView hides Edit for non-draft statuses
12. Inspection list links field techs to read-only view for non-drafts
13. Email notification fires on submission when admin has it enabled
14. Notification settings API works (GET returns defaults, PUT updates)
</verification>

<success_criteria>
- Dan can navigate to /review and see a list of submitted inspections
- Dan can open an inspection in the review editor and see all field data in collapsible sections alongside a PDF preview
- Dan can edit any field, save changes, and regenerate the PDF to see updates
- Dan can download the PDF at any point during review
- Dan can finalize a report (locks it) or return it to the tech with a note
- Dan can reopen a finalized report for further edits
- Finalized inspections show a clear "Completed" badge and are read-only
- Field techs see their non-draft inspections as read-only in the list/detail views
- Email notification sends when configured and admin has opted in
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-workflow/04-02-SUMMARY.md`
</output>
