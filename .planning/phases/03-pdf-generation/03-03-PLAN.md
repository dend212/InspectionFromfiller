---
phase: 03-pdf-generation
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/pdf/photo-pages.ts
  - src/lib/pdf/comments-page.ts
  - src/lib/pdf/merge-pdf.ts
autonomous: true
requirements: [PDF-03, MDIA-03]

must_haves:
  truths:
    - "Photos from the inspection are appended as additional pages after the main form pages in the generated PDF"
    - "Photos are arranged 2 per page, stacked vertically, with section label + number caption"
    - "Photos are grouped by form section, not chronological order"
    - "First photo page has 'Inspection Photos' header at top"
    - "If inspector comments exceed form field space, 'See Comments' appears in the field and a dedicated comments page is appended"
    - "Comments overflow page has a proper paragraph area with section headings"
    - "PDF page order is: 6 form pages -> comments page (if needed) -> photo pages"
  artifacts:
    - path: "src/lib/pdf/photo-pages.ts"
      provides: "Builds pdfme page schemas and inputs for photo appendix (2 per page, grouped by section)"
      exports: ["buildPhotoPages"]
    - path: "src/lib/pdf/comments-page.ts"
      provides: "Detects comment overflow and builds comments overflow page template + inputs"
      exports: ["buildCommentsPage"]
    - path: "src/lib/pdf/merge-pdf.ts"
      provides: "Merges form PDF + comments PDF + photo PDF into a single output using pdf-lib"
      exports: ["mergeGeneratedPdfs"]
  key_links:
    - from: "src/lib/pdf/photo-pages.ts"
      to: "src/components/inspection/media-gallery.tsx"
      via: "uses MediaRecord type to identify photos by section"
      pattern: "import.*MediaRecord"
    - from: "src/lib/pdf/photo-pages.ts"
      to: "src/lib/supabase/client.ts"
      via: "creates Supabase client to fetch signed URLs for photo data"
      pattern: "import.*createClient.*supabase"
    - from: "src/lib/pdf/merge-pdf.ts"
      to: "@pdfme/generator"
      via: "generates separate PDFs for form, comments, and photos, then merges with pdf-lib"
      pattern: "import.*PDFDocument.*pdf-lib"
    - from: "src/lib/pdf/comments-page.ts"
      to: "src/lib/pdf/field-mapping.ts"
      via: "uses detectCommentOverflow to identify which comments need overflow pages"
      pattern: "import.*detectCommentOverflow"
---

<objective>
Build photo page generation (2 photos per page, grouped by section) and comments overflow page handling, plus the pdf-lib merge utility that combines form PDF + comments + photos into the final output.

Purpose: Inspection reports include visual evidence (photos) appended after the form, and inspectors sometimes write comments that exceed the form's small text fields. This plan ensures nothing is lost: long comments get a dedicated page, photos get clean appendix pages, and everything merges into one downloadable PDF.

Output: `photo-pages.ts` (photo appendix builder), `comments-page.ts` (overflow handler), `merge-pdf.ts` (PDF merger). These integrate with the generate-report.ts from Plan 02.
</objective>

<execution_context>
@/Users/danielendres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielendres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-pdf-generation/03-RESEARCH.md
@.planning/phases/03-pdf-generation/03-01-SUMMARY.md
@src/lib/pdf/template.ts
@src/lib/pdf/field-mapping.ts
@src/components/inspection/media-gallery.tsx
@src/lib/supabase/client.ts
@src/lib/constants/inspection.ts

<interfaces>
<!-- From Plan 01 outputs -->

From src/lib/pdf/template.ts:
```typescript
export async function loadTemplate(): Promise<{
  template: Template;
  font: Record<string, { data: ArrayBuffer; fallback?: boolean }>;
}>;
```

From src/lib/pdf/field-mapping.ts:
```typescript
export function detectCommentOverflow(data: InspectionFormData): {
  hasOverflow: boolean;
  overflowSections: Array<{ section: string; fieldName: string; text: string }>;
};
```

From src/components/inspection/media-gallery.tsx:
```typescript
export interface MediaRecord {
  id: string;
  type: "photo" | "video";
  storagePath: string;
  label: string | null;
  sortOrder: number | null;
  createdAt: string;
}
```

From src/lib/constants/inspection.ts:
```typescript
export const STEP_LABELS = [
  "Facility Info", "General Treatment", "Design Flow",
  "Septic Tank", "Disposal Works"
] as const;
```

pdfme generate API:
```typescript
import { generate } from '@pdfme/generator';
// generate({ template, inputs, plugins, options }) => Promise<Uint8Array>
```

pdf-lib merge pattern:
```typescript
import { PDFDocument } from 'pdf-lib';
const merged = await PDFDocument.create();
const doc1 = await PDFDocument.load(uint8Array1);
const pages = await merged.copyPages(doc1, doc1.getPageIndices());
pages.forEach(p => merged.addPage(p));
const result = await merged.save(); // Uint8Array
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create photo page builder and comments overflow page</name>
  <files>
    src/lib/pdf/photo-pages.ts
    src/lib/pdf/comments-page.ts
  </files>
  <action>
1. **photo-pages.ts**: Build photo appendix pages for the PDF.

   ```typescript
   export async function buildPhotoPages(
     media: MediaRecord[],
   ): Promise<Uint8Array | null>
   ```

   Implementation:
   - Filter media to only `type === 'photo'` records
   - If no photos, return null (no photo pages needed)
   - Group photos by their `label` field (which contains the section name, e.g., "Facility Info", "Septic Tank"). Photos without labels go into an "Other" group. Group order follows STEP_LABELS order from constants.
   - For each group of photos, arrange 2 per page stacked vertically:

   Photo page template (use blank basePdf with letter dimensions):
   ```typescript
   const BLANK_PAGE = { width: 215.9, height: 279.4, padding: [10, 10, 10, 10] };
   ```

   Each photo page schema:
   - Header text: "Inspection Photos" on the FIRST photo page only. On subsequent pages, use the section group name.
   - Photo 1: image schema at top of page (below header), ~175mm wide, ~110mm tall
   - Caption 1: text schema below photo 1 with section label + sequential number (e.g., "Septic Tank - Photo 1")
   - Photo 2: image schema below caption 1, same dimensions
   - Caption 2: text schema below photo 2

   If a page has only 1 photo (odd number in group), leave photo2 and caption2 as empty strings.

   Photo data fetching:
   - Create a Supabase client using `createClient()` from `@/lib/supabase/client`
   - For each photo, create a signed URL via `supabase.storage.from('inspection-media').createSignedUrl(storagePath, 3600)`
   - Fetch the signed URL, convert response to ArrayBuffer, then to base64 data URL: `data:image/jpeg;base64,{base64string}`
   - pdfme's image schema accepts this data URL format

   Generate the photo pages PDF:
   - Build a pdfme Template with `basePdf: BLANK_PAGE` and `schemas` for all photo pages
   - Build corresponding `inputs` array (one input object per page)
   - Call `generate({ template, inputs, plugins: { text, image }, options: { font } })`
   - Return the Uint8Array result

   Per user decision: 2 photos per page stacked vertically. Each captioned with section label + number. Grouped by form section. "Inspection Photos" header on first page.

2. **comments-page.ts**: Build comments overflow page.

   ```typescript
   export async function buildCommentsPage(
     overflowSections: Array<{ section: string; fieldName: string; text: string }>,
   ): Promise<Uint8Array | null>
   ```

   Implementation:
   - If `overflowSections` is empty, return null (no overflow page needed)
   - Build a single-page pdfme template with blank basePdf (letter size)
   - Schema layout:
     - Title: "Inspector Comments (Continued)" at top, centered, bold, 14pt
     - For each overflow section, add:
       - Section heading text: e.g., "Design Flow Comments", bold, 12pt
       - Comment body text: the full comment text, 10pt, left-aligned, multi-line
       - Use generous height for comment body (calculated based on text length)
   - If multiple overflow sections exist, stack them vertically with spacing

   **NOTE:** pdfme text schemas have a fixed height. For long comments, set a large height (e.g., 80mm per section) and rely on dynamicFontSize to shrink if needed. If a single comment is extremely long (>1000 chars), consider splitting across multiple pages, but this is an edge case for inspection comments.

   Per user decision: comments overflow page should have a proper paragraph area, not just raw text dump. "See Comments" in the form field when overflow detected.
  </action>
  <verify>
    <automated>cd "$(pwd)" && npx tsc --noEmit src/lib/pdf/photo-pages.ts src/lib/pdf/comments-page.ts 2>&1 | head -30</automated>
  </verify>
  <done>
  - photo-pages.ts exports buildPhotoPages() that fetches photos from Supabase, groups by section, creates 2-per-page layout
  - comments-page.ts exports buildCommentsPage() that creates a formatted overflow page for long comments
  - Photo captions include section label and sequential number
  - Photos grouped by form section in STEP_LABELS order
  - First photo page has "Inspection Photos" header
  - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PDF merge utility and integrate with generate-report</name>
  <files>
    src/lib/pdf/merge-pdf.ts
    src/lib/pdf/generate-report.ts
  </files>
  <action>
1. Install pdf-lib (for merging separately-generated PDFs):
   ```bash
   npm install pdf-lib
   ```

   Note: pdfme uses @pdfme/pdf-lib internally, but we need the standalone pdf-lib for our merge utility since @pdfme/pdf-lib is not exported as a public API.

2. **merge-pdf.ts**: Create the PDF merge utility.

   ```typescript
   export async function mergeGeneratedPdfs(
     formPdf: Uint8Array,
     commentsPdf: Uint8Array | null,
     photosPdf: Uint8Array | null,
   ): Promise<Uint8Array>
   ```

   Implementation:
   - Create a new `PDFDocument` using `PDFDocument.create()` from pdf-lib
   - Load `formPdf` as a PDFDocument, copy ALL its pages into the merged document
   - If `commentsPdf` is not null, load it and copy its pages (appended after form pages)
   - If `photosPdf` is not null, load it and copy its pages (appended after comments)
   - Save the merged document as `Uint8Array` via `merged.save()`
   - Return the result

   Page order: form pages (6) -> comments page(s) -> photo pages. Per user decision.

3. **Update generate-report.ts**: Extend the existing `generateReport` function to support the full pipeline.

   Update the function signature:
   ```typescript
   export async function generateReport(
     formData: InspectionFormData,
     signatureDataUrl: string | null,
     media?: MediaRecord[],
   ): Promise<Uint8Array>
   ```

   Updated implementation:
   - Steps 1-4 remain the same (load template, map data, embed signature, generate form PDF)
   - NEW Step 5: Check for comment overflow using `detectCommentOverflow(formData)`
     - If overflow detected, update the form inputs to put "See Comments" in overflow fields
     - Build comments page using `buildCommentsPage(overflowSections)`
   - NEW Step 6: Build photo pages using `buildPhotoPages(media ?? [])` -- only if media array has photos
   - NEW Step 7: Merge all PDFs using `mergeGeneratedPdfs(formPdf, commentsPdf, photosPdf)`
   - Return the merged result

   **IMPORTANT:** The overflow detection must happen BEFORE generating the form PDF, because it modifies the inputs (replacing overflow text with "See Comments"). The flow is:
   1. Map form data to inputs
   2. Detect overflow and modify inputs if needed
   3. Generate form PDF (with modified inputs)
   4. Generate comments page (with original overflow text)
   5. Generate photo pages
   6. Merge all

   Also update the inspection detail page's generate handler to pass media records to generateReport().
  </action>
  <verify>
    <automated>cd "$(pwd)" && npx tsc --noEmit src/lib/pdf/merge-pdf.ts src/lib/pdf/generate-report.ts 2>&1 | head -30</automated>
  </verify>
  <done>
  - merge-pdf.ts exports mergeGeneratedPdfs() that combines form + comments + photo PDFs via pdf-lib
  - generate-report.ts updated to accept media parameter, handle overflow, build photo/comment pages, and merge
  - PDF page order: form pages -> comments page (conditional) -> photo pages (conditional)
  - "See Comments" placed in form field when comment overflows
  - Full pipeline works end-to-end: data -> form PDF -> merge with appended pages -> final output
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new and modified files
2. Photo pages generate correctly with 2 photos per page stacked vertically
3. Photos are grouped by section and captioned with section label + number
4. Comments overflow page generates only when comments exceed threshold
5. "See Comments" appears in form field when overflow detected
6. PDF merge produces correct page order: form -> comments -> photos
7. Final PDF opens correctly in browser viewer
8. When no photos exist, no photo pages appended
9. When no comments overflow, no comments page appended
</verification>

<success_criteria>
- Photo appendix pages work end-to-end: fetch from Supabase, convert to base64, generate pages, merge
- Comments overflow detection catches long comments and produces clean overflow page
- PDF merge correctly combines 1-3 separate PDFs into final output
- Page ordering matches user requirement: form pages, then comments, then photos
- No photos = no photo pages (graceful handling)
- No overflow = no comments page (graceful handling)
</success_criteria>

<output>
After completion, create `.planning/phases/03-pdf-generation/03-03-SUMMARY.md`
</output>
