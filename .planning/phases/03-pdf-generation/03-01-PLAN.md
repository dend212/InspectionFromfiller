---
phase: 03-pdf-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/pdf/template.ts
  - src/lib/pdf/field-mapping.ts
  - public/fonts/LiberationSans-Regular.ttf
  - public/fonts/LiberationSans-Bold.ttf
autonomous: true
requirements: [PDF-01]

must_haves:
  truths:
    - "pdfme template schema defines text/image schemas for every data field across all 6 pages of the ADEQ form"
    - "Field mapping function converts InspectionFormData (Zod schema shape) to flat Record<string, string> inputs for pdfme"
    - "Checkbox fields render as 'X' character overlays using text schemas at checkbox coordinates"
    - "dynamicFontSize is configured on text fields that may overflow (addresses, names, comments)"
    - "Free Helvetica-alike font files are available in public/fonts for pdfme to load at runtime"
  artifacts:
    - path: "src/lib/pdf/template.ts"
      provides: "Complete pdfme Template with basePdf loader and schemas[][] for all 6 ADEQ form pages"
      exports: ["loadTemplate", "ADEQ_TEMPLATE_SCHEMAS"]
    - path: "src/lib/pdf/field-mapping.ts"
      provides: "Transforms InspectionFormData into pdfme inputs Record plus overflow detection"
      exports: ["mapFormDataToInputs", "detectCommentOverflow"]
    - path: "public/fonts/LiberationSans-Regular.ttf"
      provides: "Free Helvetica-alike regular weight font for PDF text rendering"
    - path: "public/fonts/LiberationSans-Bold.ttf"
      provides: "Free Helvetica-alike bold weight font for PDF headers"
  key_links:
    - from: "src/lib/pdf/field-mapping.ts"
      to: "src/lib/validators/inspection.ts"
      via: "imports InspectionFormData type, maps every Zod field to a pdfme input key"
      pattern: "import.*InspectionFormData"
    - from: "src/lib/pdf/template.ts"
      to: "public/septic_system_insp_form.pdf"
      via: "fetch() loads the blank form PDF as basePdf at runtime"
      pattern: "fetch.*septic_system_insp_form"
---

<objective>
Create the pdfme template schema mapping all ~100+ ADEQ GWS 432 form fields to precise mm coordinates across 6 PDF pages, plus the field-mapping layer that transforms InspectionFormData into pdfme inputs.

Purpose: This is the data foundation for all PDF generation. The template defines WHERE text appears on each page; the field mapping defines WHAT text appears. Both must exist before any PDF can be generated.

Output: `src/lib/pdf/template.ts` (template schema + basePdf loader), `src/lib/pdf/field-mapping.ts` (data transformer), font files in `public/fonts/`.
</objective>

<execution_context>
@/Users/danielendres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielendres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-pdf-generation/03-RESEARCH.md
@src/lib/validators/inspection.ts
@src/lib/constants/inspection.ts
@src/types/inspection.ts
@septic_system_insp_form.pdf
@Adeq Report1.pdf

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/types/inspection.ts:
```typescript
export type FacilityInfo = z.infer<typeof facilityInfoSchema>;
export type GeneralTreatment = z.infer<typeof generalTreatmentSchema>;
export type DesignFlow = z.infer<typeof designFlowSchema>;
export type SepticTank = z.infer<typeof septicTankSchema>;
export type DisposalWorks = z.infer<typeof disposalWorksSchema>;
export type InspectionFormData = z.infer<typeof inspectionFormSchema>;
```

From src/lib/validators/inspection.ts:
```typescript
export const inspectionFormSchema = z.object({
  facilityInfo: facilityInfoSchema,
  generalTreatment: generalTreatmentSchema,
  designFlow: designFlowSchema,
  septicTank: septicTankSchema,
  disposalWorks: disposalWorksSchema,
});
```

pdfme v5 Template type:
```typescript
import type { Template } from '@pdfme/common';
// Template = { basePdf: string | ArrayBuffer | Uint8Array, schemas: Schema[][] }
// Schema = { name: string, type: string, position: { x: number, y: number }, width: number, height: number, ... }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install pdfme packages and download Liberation Sans fonts</name>
  <files>
    package.json
    public/fonts/LiberationSans-Regular.ttf
    public/fonts/LiberationSans-Bold.ttf
  </files>
  <action>
1. Install pdfme runtime packages:
   ```bash
   npm install @pdfme/generator @pdfme/common @pdfme/schemas
   ```

2. Download Liberation Sans font files (free Helvetica-alike, SIL Open Font License) into `public/fonts/`:
   - LiberationSans-Regular.ttf (for body text)
   - LiberationSans-Bold.ttf (for headers/labels)

   Source: https://github.com/liberationfonts/liberation-fonts/releases -- download the latest TTF release and extract the two files. If GitHub download is unavailable, use the system-installed version at `/usr/share/fonts/truetype/liberation/` or download from a CDN.

3. Copy `septic_system_insp_form.pdf` into `public/` so it's servable via fetch() at runtime:
   ```bash
   cp septic_system_insp_form.pdf public/septic_system_insp_form.pdf
   ```

Per user decision: use clean Arial/Helvetica-style font. Liberation Sans is the free equivalent (metrically compatible with Arial). Do NOT use handwriting fonts.
  </action>
  <verify>
    <automated>ls -la public/fonts/LiberationSans-Regular.ttf public/fonts/LiberationSans-Bold.ttf public/septic_system_insp_form.pdf && node -e "require('@pdfme/generator'); require('@pdfme/common'); require('@pdfme/schemas'); console.log('pdfme packages OK')"</automated>
  </verify>
  <done>pdfme packages installed, Liberation Sans font files in public/fonts/, blank ADEQ form PDF in public/ directory</done>
</task>

<task type="auto">
  <name>Task 2: Create pdfme template schema and field-mapping module</name>
  <files>
    src/lib/pdf/template.ts
    src/lib/pdf/field-mapping.ts
  </files>
  <action>
**template.ts**: Create the pdfme Template module.

1. Export an async `loadTemplate()` function that:
   - Fetches `/septic_system_insp_form.pdf` as ArrayBuffer (the basePdf)
   - Fetches `/fonts/LiberationSans-Regular.ttf` and `/fonts/LiberationSans-Bold.ttf` as ArrayBuffer
   - Returns a `{ template: Template, font: Record<string, { data: ArrayBuffer, fallback?: boolean }> }` object
   - Caches the loaded template + fonts in module-level variables so subsequent calls don't re-fetch

2. Export `ADEQ_TEMPLATE_SCHEMAS: Schema[][]` -- the schema array defining all field positions:
   - Array of 6 inner arrays (one per PDF page)
   - Page 1 (instructions page "PAGE i"): empty array `[]` -- no overlays
   - Pages 2-6 (form pages 1-5): schemas for all text fields, checkbox positions, and signature image

   **CRITICAL FIELD MAPPING APPROACH:**
   Open `septic_system_insp_form.pdf` (6 pages) and `Adeq Report1.pdf` (filled example, 7 pages with cover) as visual references. The blank form has fields at specific positions. Use the filled example to identify where text should land.

   For coordinate estimation, use US Letter = 215.9mm x 279.4mm. The ADEQ form is a standard letter-size document. Estimate field positions in mm from top-left of each page. The pdfme Designer can refine these later, but provide reasonable initial estimates based on form layout.

   For each field schema, use this pattern:
   ```typescript
   {
     name: 'fieldName',        // Must match key in mapFormDataToInputs output
     type: 'text',
     position: { x: NUMBER, y: NUMBER },  // mm from top-left
     width: NUMBER,             // mm
     height: NUMBER,            // mm (typically 5-6mm for single-line text)
     fontSize: 10,
     dynamicFontSize: { min: 6, max: 10, fit: 'horizontal' },  // For fields that may overflow
     fontName: 'LiberationSans',
     alignment: 'left',
     verticalAlignment: 'middle',
     fontColor: '#000000',
     backgroundColor: '',
     lineHeight: 1,
     characterSpacing: 0,
   }
   ```

   For checkbox fields, use text type with centered "X":
   ```typescript
   {
     name: 'checkboxFieldName',
     type: 'text',
     position: { x: NUMBER, y: NUMBER },
     width: 4, height: 4,       // Small box matching checkbox size
     fontSize: 10,
     alignment: 'center',
     verticalAlignment: 'middle',
     fontName: 'LiberationSans',
     fontColor: '#000000',
     backgroundColor: '',
     lineHeight: 1,
     characterSpacing: 0,
   }
   ```

   For the signature image (on the last form page, Section 5 signature area):
   ```typescript
   {
     name: 'signatureImage',
     type: 'image',
     position: { x: NUMBER, y: NUMBER },
     width: 60, height: 20,    // Approximate signature area dimensions
   }
   ```

   **Page-by-page field layout guide (from ADEQ GWS 432):**

   PAGE 2 (Form Page 1 -- top portion): Inspector/Facility header area
   - Facility name, address, city, county, state, zip, tax parcel, inspection date
   - Seller/transferor name, address, city, state, zip
   - Inspector name, company, address, certification, registration, truck number
   - Inspector qualifications checkboxes (ADEQ course, PE, RS, WW operator, licensed contractor, pumper truck)
   - Records obtained checkboxes (discharge auth, approval of construction, site plan, operation docs, other)
   - Cesspool yes/no

   PAGE 3 (Form Page 2 -- Section 1 & 2): Facility Info + General Treatment
   - Water source, well distance, wastewater source, occupancy type
   - Summary of Inspection: facility type, system types, number of systems, age
   - Condition ratings (septic tank, disposal works, alternative system, alternative disposal)
   - Section 2: GP 4.02-4.23 system type checkboxes (approximately 23 checkbox positions)
   - Performance assurance plan yes/no

   PAGE 4 (Form Page 3 -- Section 3 & 4A-4F): Design Flow + Tank Inspection start
   - Design flow GPD, basis, bedrooms, fixtures, non-dwelling GPD
   - Actual flow evaluation
   - Design flow comments
   - Number of tanks, pumping yes/no, hauler info
   - Tank liquid levels, scum/sludge thickness

   PAGE 5 (Form Page 4 -- Section 4G-4M): Tank Inspection continued
   - Tank dimensions, capacity, basis
   - Tank material, access openings
   - Lids/risers, compartments, compromised tank
   - Deficiencies checkboxes (8 items)
   - Baffle material and conditions
   - Effluent filter
   - Septic tank comments

   PAGE 6 (Form Page 5 -- Section 4.1 & 5): Disposal Works + Signature
   - Disposal works location, type, distribution method
   - Supply line material, component inspection
   - Inspection ports, hydraulic load test
   - Disposal deficiencies checkboxes (11 items)
   - Repairs recommended
   - Inspector comments/summary
   - Signature image, date, printed name

   **NOTE:** Initial coordinates will be approximate. The pdfme Designer can be used later to fine-tune. Focus on getting EVERY field represented with reasonable positions. It's better to have all fields present at roughly-correct positions than to have half the fields at perfect positions.

   Each field name in the schema MUST match a key returned by `mapFormDataToInputs()` in the field-mapping module.

**field-mapping.ts**: Create the data transformation layer.

1. Export `mapFormDataToInputs(data: InspectionFormData): Record<string, string>` that:
   - Maps every facilityInfo field to its template key (e.g., `data.facilityInfo.facilityName` -> `{ facilityName: data.facilityInfo.facilityName }`)
   - Converts boolean checkbox fields to `"X"` (true) or `""` (false)
   - Converts enum fields to display-friendly text using constants from `src/lib/constants/inspection.ts`
   - Handles the systemTypes array (generalTreatment.systemTypes) by mapping each selected type to its corresponding checkbox key (e.g., `gp402_conventional` -> `{ checkbox_gp402_conventional: "X" }`)
   - Handles per-tank array data (septicTank.tanks) by flattening tank[0] fields into `tank1_liquidLevel`, `tank1_scumThickness`, etc. (support up to 3 tanks)
   - Handles the `facilitySystemTypes` array similarly to systemTypes
   - Maps condition ratings to their display labels using CONDITION_OPTIONS
   - Maps enum values (waterSource, disposalType, etc.) to display labels using the constant arrays
   - Passes through string fields directly (no transformation needed)
   - Returns empty string `""` for any undefined/null values (pdfme renders nothing for empty strings)

2. Export `detectCommentOverflow(data: InspectionFormData): { hasOverflow: boolean, overflowSections: Array<{ section: string, fieldName: string, text: string }> }` that:
   - Checks comment fields that have limited space on the form: `designFlow.designFlowComments`, `septicTank.septicTankComments`, `disposalWorks.disposalWorksComments`
   - Uses a character count heuristic (~200 chars for typical form field at 10pt font in the available width)
   - If any comment exceeds the threshold, returns `hasOverflow: true` and the overflow details
   - When overflow detected, `mapFormDataToInputs` should put "See Comments" in the form field instead of the full text

Per user decision: checkboxes rendered as "X" character, not styled checkbox graphics. Clean font (Arial/Helvetica-style = Liberation Sans). Auto-shrink font via dynamicFontSize for fields with limited space.
  </action>
  <verify>
    <automated>cd "$(pwd)" && npx tsc --noEmit src/lib/pdf/template.ts src/lib/pdf/field-mapping.ts 2>&1 | head -30</automated>
  </verify>
  <done>
  - template.ts exports loadTemplate() and ADEQ_TEMPLATE_SCHEMAS with schemas for all 6 PDF pages
  - field-mapping.ts exports mapFormDataToInputs() covering every InspectionFormData field and detectCommentOverflow()
  - Every checkbox field maps to "X" or ""
  - dynamicFontSize configured on fields that may overflow
  - signatureImage schema defined as image type on the last form page
  - All field names in template schemas have corresponding keys in mapFormDataToInputs output
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for both new files (no type errors)
2. Template schemas array has exactly 6 inner arrays (matching 6 PDF pages)
3. Page 1 schemas array is empty (instructions page, no overlays)
4. Every field in InspectionFormData has a corresponding entry in both the template schema and the field mapping
5. Checkbox fields use text type with alignment: 'center' and small width/height (~4mm)
6. Signature field uses image type
7. Font files exist in public/fonts/
8. Blank form PDF exists in public/ directory
</verification>

<success_criteria>
- pdfme packages installed and importable
- Template module defines schemas for all ~100+ form fields across 6 pages
- Field mapping transforms the complete InspectionFormData type to flat pdfme inputs
- Comment overflow detection identifies long comments and provides "See Comments" substitution
- Font files available for runtime loading
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-pdf-generation/03-01-SUMMARY.md`
</output>
