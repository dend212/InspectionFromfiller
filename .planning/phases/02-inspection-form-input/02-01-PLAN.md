---
phase: 02-inspection-form-input
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/validators/inspection.ts
  - src/lib/constants/inspection.ts
  - src/types/inspection.ts
  - src/app/api/inspections/route.ts
  - src/app/api/inspections/[id]/route.ts
  - src/app/(dashboard)/inspections/page.tsx
  - src/app/(dashboard)/inspections/new/page.tsx
autonomous: true
requirements: [FORM-01, FORM-04]

must_haves:
  truths:
    - "Zod schemas exist for all 5 ADEQ form sections with correct field names matching the official form"
    - "Creating a new inspection via POST /api/inspections returns a draft inspection with pre-filled inspector info"
    - "Loading an inspection via GET /api/inspections/[id] returns the inspection with all form data"
    - "Saving form data via PATCH /api/inspections/[id] updates the formData JSONB column and denormalized facility fields"
    - "Inspections list page shows the user's draft inspections"
    - "New inspection page creates a draft and redirects to the edit wizard"
  artifacts:
    - path: "src/lib/validators/inspection.ts"
      provides: "Zod v4 schemas for all 5 ADEQ sections + combined schema + per-step field arrays"
      exports: ["facilityInfoSchema", "generalTreatmentSchema", "designFlowSchema", "septicTankSchema", "disposalWorksSchema", "inspectionFormSchema", "STEP_FIELDS"]
    - path: "src/lib/constants/inspection.ts"
      provides: "ADEQ field options: AZ counties, facility types, system types, disposal types"
      exports: ["AZ_COUNTIES", "FACILITY_TYPES", "SYSTEM_TYPES", "DISPOSAL_TYPES", "INSPECTOR_DEFAULTS", "STEP_LABELS"]
    - path: "src/types/inspection.ts"
      provides: "TypeScript types inferred from Zod schemas"
      exports: ["InspectionFormData", "FacilityInfo", "GeneralTreatment", "DesignFlow", "SepticTank", "DisposalWorks"]
    - path: "src/app/api/inspections/route.ts"
      provides: "POST (create inspection) and GET (list inspections) endpoints"
      exports: ["POST", "GET"]
    - path: "src/app/api/inspections/[id]/route.ts"
      provides: "GET (load) and PATCH (auto-save) endpoints for a single inspection"
      exports: ["GET", "PATCH"]
    - path: "src/app/(dashboard)/inspections/page.tsx"
      provides: "Inspections list with draft cards showing facility name, date, status"
    - path: "src/app/(dashboard)/inspections/new/page.tsx"
      provides: "Creates new inspection via API and redirects to /inspections/[id]/edit"
  key_links:
    - from: "src/app/api/inspections/route.ts"
      to: "src/lib/db/schema.ts"
      via: "Drizzle insert/select on inspections table"
      pattern: "db\\.insert\\(inspections\\)|db\\.select\\(\\)"
    - from: "src/app/api/inspections/[id]/route.ts"
      to: "src/lib/db/schema.ts"
      via: "Drizzle update/select with eq(inspections.id)"
      pattern: "db\\.update\\(inspections\\)|eq\\(inspections\\.id"
    - from: "src/lib/validators/inspection.ts"
      to: "src/types/inspection.ts"
      via: "z.infer type exports"
      pattern: "z\\.infer"
---

<objective>
Define all ADEQ GWS 432 form data contracts (Zod schemas, TypeScript types, constants), build the inspection CRUD API routes, and create the inspections list and new-inspection pages.

Purpose: Establishes the complete data layer that the wizard UI (Plan 02-02) and media features (Plan 02-03) build upon. Defines exact field names and validation rules matching the official ADEQ form. Pre-fills inspector credentials on creation (FORM-04).

Output: Zod schemas for 5 sections, TypeScript types, API routes for create/load/save inspections, inspections list page, new-inspection redirect page.
</objective>

<execution_context>
@/Users/danielendres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielendres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inspection-form-input/02-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/db/schema.ts:
```typescript
export const inspections = pgTable("inspections", {
  id: uuid("id").defaultRandom().primaryKey(),
  inspectorId: uuid("inspector_id").references(() => profiles.id).notNull(),
  status: inspectionStatusEnum("status").default("draft").notNull(),
  facilityName: text("facility_name"),
  facilityAddress: text("facility_address"),
  facilityCity: text("facility_city"),
  facilityCounty: text("facility_county"),
  facilityState: varchar("facility_state", { length: 2 }).default("AZ"),
  facilityZip: varchar("facility_zip", { length: 10 }),
  formData: jsonb("form_data"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  submittedAt: timestamp("submitted_at"),
  completedAt: timestamp("completed_at"),
});

export const inspectionMedia = pgTable("inspection_media", {
  id: uuid("id").defaultRandom().primaryKey(),
  inspectionId: uuid("inspection_id").references(() => inspections.id, { onDelete: "cascade" }).notNull(),
  type: text("type").notNull(), // 'photo' or 'video'
  storagePath: text("storage_path").notNull(),
  label: text("label"),
  sortOrder: integer("sort_order").default(0),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const profiles = pgTable("profiles", {
  id: uuid("id").primaryKey(),
  fullName: text("full_name").notNull(),
  email: text("email").notNull(),
  phone: varchar("phone", { length: 20 }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});
```

From src/lib/supabase/server.ts:
```typescript
export async function createClient(): Promise<SupabaseClient>;
```

From src/lib/supabase/client.ts:
```typescript
export function createClient(): SupabaseClient;
```

From src/lib/db/index.ts:
```typescript
export const db: DrizzleInstance;
```

From src/lib/validators/auth.ts (pattern reference):
```typescript
import { z } from "zod";
export const loginSchema = z.object({ ... });
export type LoginFormData = z.infer<typeof loginSchema>;
```

From src/types/roles.ts:
```typescript
export type AppRole = "admin" | "field_tech" | "office_staff";
```
</interfaces>

**ADEQ GWS 432 Form Field Reference:**
The form has 5 sections matching the official ADEQ Aquifer Protection Permit (APP) Inspection Report (GWS 432). The executor MUST read `Adeq Report1.pdf` (in project root) to extract the exact field inventory for each section. The 5 sections are:

1. **Section 1 - Facility Information:** Facility name, address, city, county, state, zip, tax parcel #, owner name, owner address, owner phone, contact person, facility type (single family/multifamily/commercial/other), date of inspection, APP #, inspector name, company, certification #, registration #, truck #, type of inspection (routine/complaint/permit/other).

2. **Section 2 - General Treatment System Information:** General Permit 4.02 system (yes/no), Type I/II/III/IV designation, alternative treatment system toggle (show/hide additional fields), alternative system manufacturer, model, capacity, date installed, system condition checkboxes. This section has rarely-used alternative fields that must be collapsed by default (FORM-02).

3. **Section 3 - Design Flow Calculations:** Number of bedrooms, flow per bedroom, total design flow, other flow sources, total system design flow, actual daily flow if metered. Calculation fields.

4. **Section 4 - Septic Tank Inspection:** Number of tanks, per-tank fields (manufacturer, capacity, material, liquid depth, scum thickness, sludge depth, inlet/outlet condition, baffles, risers, tank condition), tank condition checkboxes (cracks, corrosion, leaking, structural damage, etc.) -- large tap-friendly toggle rows per CONTEXT.md.

5. **Section 5 - Disposal Works Inspection:** Disposal type (conventional trench/bed/chamber/mound/drip/other), number of lines/sections, condition items (distribution box, dosing chamber, pump, timer, effluent quality, soil conditions, vegetation), additional findings, inspector summary/recommendations, inspector signature date.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Zod schemas, TypeScript types, and ADEQ constants for all 5 form sections</name>
  <files>
    src/lib/validators/inspection.ts
    src/lib/constants/inspection.ts
    src/types/inspection.ts
  </files>
  <action>
**Read `Adeq Report1.pdf` in the project root** to extract the exact field names for each section. Then create:

**1. `src/lib/constants/inspection.ts`** -- ADEQ dropdown options and defaults:
- `AZ_COUNTIES`: Array of all 15 Arizona counties as `{ value, label }` objects
- `FACILITY_TYPES`: Single Family Residence, Multifamily, Commercial, Other
- `INSPECTION_TYPES`: Routine, Complaint, Permit, Other
- `GP402_SYSTEM_TYPES`: Type I, Type II, Type III, Type IV
- `TANK_MATERIALS`: Concrete, Fiberglass, Plastic, Other
- `DISPOSAL_TYPES`: Conventional Trench, Bed, Chamber, Mound, Drip, Other
- `CONDITION_OPTIONS`: Satisfactory, Unsatisfactory, N/A
- `INSPECTOR_DEFAULTS`: `{ company: "SewerTime Septic", certificationNumber: "NAWT #15805", registrationNumber: "CR-37", truckNumber: "ADEQ Truck #2833" }` -- these are hardcoded company credentials per FORM-04
- `STEP_LABELS`: Array of 5 step names: "Facility Info", "General Treatment", "Design Flow", "Septic Tank", "Disposal Works"
- Export all as `const` (not `as const` unless needed for type inference)

**2. `src/lib/validators/inspection.ts`** -- Zod v4 schemas:
- `facilityInfoSchema`: z.object with fields for facility name, address, city, county (dropdown), state (default "AZ"), zip, taxParcelNumber, ownerName, ownerAddress, ownerPhone, contactPerson, facilityType (enum from constants), dateOfInspection, appNumber, inspectorName, company, certificationNumber, registrationNumber, truckNumber, inspectionType. Most fields `z.string().optional()` except facilityName and inspectorName which use `z.string().min(1, ...)`.
- `generalTreatmentSchema`: z.object with gp402System (boolean), systemType (Type I-IV), alternativeSystem (boolean toggle for FORM-02 conditional fields), altSystemManufacturer, altSystemModel, altSystemCapacity, altSystemDateInstalled, altSystemCondition. Standard system condition fields.
- `designFlowSchema`: z.object with numberOfBedrooms (z.coerce.number()), flowPerBedroom (z.coerce.number()), totalDesignFlow (z.coerce.number()), otherFlowSources, totalSystemDesignFlow (z.coerce.number()), actualDailyFlow.
- `septicTankSchema`: z.object with numberOfTanks (z.coerce.number()), tanks (z.array of tank objects: manufacturer, capacity, material, liquidDepth, scumThickness, sludgeDepth, inletCondition, outletCondition, baffles, risers, condition checkboxes as boolean fields: cracks, corrosion, leaking, structuralDamage, etc.).
- `disposalWorksSchema`: z.object with disposalType, numberOfLines (z.coerce.number()), condition items as individual fields (distributionBox, dosingChamber, pump, timer, effluentQuality, soilConditions, vegetation -- each with condition rating), additionalFindings (textarea), summary (textarea), recommendations (textarea), signatureDate.
- `inspectionFormSchema`: z.object wrapping all 5 as nested objects: `{ facilityInfo, generalTreatment, designFlow, septicTank, disposalWorks }`
- `STEP_FIELDS`: Record<number, string[]> mapping step index (0-4) to arrays of dotted field paths for that step (e.g., `0: ["facilityInfo.facilityName", "facilityInfo.facilityAddress", ...]`). Used by `form.trigger()` for per-step validation.
- `DEFAULT_FORM_VALUES`: A function `getDefaultFormValues(inspectorName: string)` that returns a complete default form object with inspector info pre-filled from INSPECTOR_DEFAULTS constant + the provided inspector name.

Use Zod v4 syntax (the project already uses Zod v4 -- see `src/lib/validators/auth.ts` for pattern reference). Use `z.string().optional().default("")` for text fields that should start empty. Use `z.coerce.number()` for numeric fields so string inputs from HTML are coerced.

**3. `src/types/inspection.ts`** -- TypeScript types inferred from Zod schemas:
```typescript
import { z } from "zod";
import { facilityInfoSchema, generalTreatmentSchema, designFlowSchema, septicTankSchema, disposalWorksSchema, inspectionFormSchema } from "@/lib/validators/inspection";

export type FacilityInfo = z.infer<typeof facilityInfoSchema>;
export type GeneralTreatment = z.infer<typeof generalTreatmentSchema>;
export type DesignFlow = z.infer<typeof designFlowSchema>;
export type SepticTank = z.infer<typeof septicTankSchema>;
export type DisposalWorks = z.infer<typeof disposalWorksSchema>;
export type InspectionFormData = z.infer<typeof inspectionFormSchema>;
```

**Important:** The Zod schemas are the source of truth. Field names in the schemas MUST match what the PATCH endpoint saves to `formData` JSONB and what the wizard step components will render. Get the field inventory right here -- the wizard UI (Plan 02-02) builds directly against these schemas.
  </action>
  <verify>
    <automated>cd "/Users/danielendres/Documents/Dans Stuff/Inspection Form Filler" && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - All 5 section schemas export from `src/lib/validators/inspection.ts`
    - Combined `inspectionFormSchema` validates the nested form structure
    - `STEP_FIELDS` maps each step index to its field paths
    - `getDefaultFormValues()` returns pre-filled inspector defaults
    - All TypeScript types export from `src/types/inspection.ts`
    - Constants export from `src/lib/constants/inspection.ts`
    - `npx tsc --noEmit` passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Build inspection CRUD API routes, inspections list page, and new-inspection page</name>
  <files>
    src/app/api/inspections/route.ts
    src/app/api/inspections/[id]/route.ts
    src/app/(dashboard)/inspections/page.tsx
    src/app/(dashboard)/inspections/new/page.tsx
  </files>
  <action>
**Install new shadcn/ui components** needed by this phase (run once, used by Plan 02-02 and 02-03):
```bash
npx shadcn@latest add switch checkbox textarea separator -y
```

**1. `src/app/api/inspections/route.ts`** -- Inspection list and create endpoints:

**POST handler (create new inspection):**
- Authenticate user via `createClient()` from `@/lib/supabase/server` + `supabase.auth.getUser()`
- Return 401 if not authenticated
- Look up the user's profile from the `profiles` table to get `fullName`
- Call `getDefaultFormValues(profile.fullName)` from validators to get pre-filled defaults (FORM-04)
- Insert into `inspections` table via Drizzle: `{ inspectorId: user.id, status: "draft", formData: defaultFormData }`
- Return 201 with the new inspection object (including `id`)

**GET handler (list inspections):**
- Authenticate user, return 401 if not
- Decode JWT to get `user_role` (same pattern as `src/app/(dashboard)/page.tsx` -- parse JWT payload for `user_role`)
- If `field_tech`: select inspections where `inspectorId = user.id`, ordered by `updatedAt desc`
- If `admin` or `office_staff`: select all inspections, ordered by `updatedAt desc`
- Return JSON array of inspections (id, status, facilityName, facilityAddress, facilityCity, facilityCounty, createdAt, updatedAt)

**2. `src/app/api/inspections/[id]/route.ts`** -- Single inspection load and save:

**GET handler (load inspection):**
- Authenticate user, return 401 if not
- Select inspection by `id` from URL params (use `const { id } = await params;` -- Next.js 16 async params)
- Verify the user owns the inspection OR is admin/office_staff (decode JWT for role)
- Return 404 if not found, 403 if unauthorized
- Return the full inspection object including `formData`

**PATCH handler (auto-save form data):**
- Authenticate user, return 401 if not
- Parse request body as JSON (this is the complete form data object)
- Update the inspection via Drizzle: set `formData` to the request body, update `updatedAt`, and sync denormalized facility fields (`facilityName`, `facilityAddress`, `facilityCity`, `facilityCounty`, `facilityZip`) from `formData.facilityInfo.*`
- Use `eq(inspections.id, id)` for the WHERE clause
- Return `{ saved: true }`

**3. `src/app/(dashboard)/inspections/page.tsx`** -- Inspections list page:
- Server component that fetches inspections via the GET API route (or directly via Drizzle for server-side rendering)
- Prefer direct Drizzle query for server component (no need to call own API)
- Display inspections as cards (use Card component from shadcn/ui)
- Each card shows: facility name (or "Untitled Inspection"), facility city, date (formatted), status badge
- Cards link to `/inspections/[id]/edit` for drafts
- Show empty state if no inspections: "No inspections yet. Start your first inspection."
- Include a "New Inspection" button linking to `/inspections/new`
- This serves as the draft cards dashboard per CONTEXT.md: "Field tech dashboard shows draft cards: facility name, date started, completion status -- tap to resume"

**4. `src/app/(dashboard)/inspections/new/page.tsx`** -- New inspection creator:
- Server component
- Authenticate user, redirect to `/login` if not
- Call the POST create inspection logic (directly via Drizzle, same as the API route but inline for server component)
- Redirect to `/inspections/[newInspection.id]/edit`
- This is a "create and redirect" page, not a form

**Patterns to follow:**
- Use `import { db } from "@/lib/db"` and `import { inspections, profiles } from "@/lib/db/schema"` for database queries
- Use `import { createClient } from "@/lib/supabase/server"` for auth in API routes
- Use `import { NextResponse } from "next/server"` for API responses
- Use `eq`, `desc` from `drizzle-orm` for query operators
- For Next.js 16 route params: `{ params }: { params: Promise<{ id: string }> }` then `const { id } = await params;`
  </action>
  <verify>
    <automated>cd "/Users/danielendres/Documents/Dans Stuff/Inspection Form Filler" && npm run build 2>&1 | tail -20</automated>
  </verify>
  <done>
    - POST /api/inspections creates a draft inspection with pre-filled inspector info and returns 201
    - GET /api/inspections returns user's inspections (field tech) or all inspections (admin/office)
    - GET /api/inspections/[id] returns a single inspection with formData
    - PATCH /api/inspections/[id] saves formData and syncs denormalized fields
    - /inspections page shows inspection cards with facility name, date, status
    - /inspections/new creates a draft and redirects to /inspections/[id]/edit
    - `npm run build` passes
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all types resolve correctly
2. `npm run build` succeeds -- all pages and API routes compile
3. Zod schemas cover all 5 ADEQ sections with correct field names
4. INSPECTOR_DEFAULTS contains exact values: SewerTime Septic, NAWT #15805, CR-37, ADEQ Truck #2833
5. API routes handle authentication and return proper status codes
</verification>

<success_criteria>
- Complete Zod schema coverage for all 5 ADEQ GWS 432 form sections
- Working CRUD API routes for inspections (create, load, save, list)
- Inspector info pre-filled on new inspection creation (FORM-04)
- Inspections list page with draft cards
- New inspection page creates and redirects to edit wizard
- All TypeScript types infer correctly from Zod schemas
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-inspection-form-input/02-01-SUMMARY.md`
</output>
