---
phase: 05-delivery-and-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/migrations/0005_delivery_dashboard.sql
  - src/lib/storage/pdf-storage.ts
  - src/app/api/inspections/[id]/finalize/route.ts
  - src/app/api/inspections/[id]/download/route.ts
  - src/app/api/inspections/[id]/route.ts
autonomous: true
requirements: [DLVR-01]

must_haves:
  truths:
    - "Finalized PDF is automatically saved to Supabase Storage when inspection status transitions to completed"
    - "Re-finalizing a completed inspection replaces the old PDF with the newly generated one"
    - "Dan can download a finalized PDF from any completed inspection"
    - "Downloaded PDF filename follows address + date format (e.g., 123-Main-St_2026-02-26.pdf)"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "inspectionEmails table, customerEmail and customerName columns on inspections"
      contains: "inspectionEmails"
    - path: "src/lib/db/migrations/0005_delivery_dashboard.sql"
      provides: "SQL migration adding customer_email, customer_name columns and inspection_emails table"
      contains: "inspection_emails"
    - path: "src/lib/storage/pdf-storage.ts"
      provides: "uploadReport and getReportDownloadUrl helper functions"
      exports: ["uploadReport", "getReportDownloadUrl"]
    - path: "src/app/api/inspections/[id]/finalize/route.ts"
      provides: "PDF generation + upload integrated into finalize transition"
      contains: "uploadReport"
    - path: "src/app/api/inspections/[id]/download/route.ts"
      provides: "GET endpoint returning signed download URL for finalized PDF"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/inspections/[id]/finalize/route.ts"
      to: "src/lib/storage/pdf-storage.ts"
      via: "uploadReport call after PDF generation"
      pattern: "uploadReport"
    - from: "src/app/api/inspections/[id]/download/route.ts"
      to: "src/lib/storage/pdf-storage.ts"
      via: "getReportDownloadUrl for signed URL"
      pattern: "getReportDownloadUrl"
    - from: "src/app/api/inspections/[id]/finalize/route.ts"
      to: "src/lib/pdf/generate-report.ts"
      via: "generateReport for server-side PDF generation"
      pattern: "generateReport"
---

<objective>
Add cloud storage for finalized PDF reports and the database schema additions needed by the entire delivery phase.

Purpose: When Dan finalizes an inspection, the PDF is automatically generated server-side and saved to Supabase Storage. This is the foundation for email delivery (Plan 02) and dashboard features (Plan 03) -- both depend on the stored PDF and new schema columns.

Output: Database migration with customer_email, customer_name, and inspection_emails table. PDF storage helpers. Updated finalize route with server-side PDF generation and upload. Download API endpoint.
</objective>

<execution_context>
@/Users/danielendres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielendres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-and-dashboard/05-RESEARCH.md
@.planning/phases/04-review-workflow/04-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/db/schema.ts:
```typescript
export const inspections = pgTable("inspections", {
  id: uuid("id").defaultRandom().primaryKey(),
  inspectorId: uuid("inspector_id").references(() => profiles.id).notNull(),
  status: inspectionStatusEnum("status").default("draft").notNull(),
  facilityName: text("facility_name"),
  facilityAddress: text("facility_address"),
  facilityCity: text("facility_city"),
  facilityCounty: text("facility_county"),
  facilityState: varchar("facility_state", { length: 2 }).default("AZ"),
  facilityZip: varchar("facility_zip", { length: 10 }),
  formData: jsonb("form_data"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  submittedAt: timestamp("submitted_at"),
  completedAt: timestamp("completed_at"),
  reviewNotes: text("review_notes"),
  finalizedPdfPath: text("finalized_pdf_path"),
  reviewedBy: uuid("reviewed_by").references(() => profiles.id),
});

export const inspectionStatusEnum = pgEnum("inspection_status", [
  "draft", "submitted", "in_review", "completed", "sent",
]);

export const profiles = pgTable("profiles", {
  id: uuid("id").primaryKey(),
  fullName: text("full_name").notNull(),
  email: text("email").notNull(),
  phone: varchar("phone", { length: 20 }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  notificationSettings: jsonb("notification_settings").default({ emailOnSubmission: false }),
});
```

From src/lib/supabase/admin.ts:
```typescript
export function createAdminClient(): SupabaseClient;
```

From src/lib/pdf/generate-report.ts:
```typescript
export async function generateReport(
  formData: InspectionFormData,
  signatureDataUrl: string | null,
  media?: MediaRecord[],
): Promise<Uint8Array>;
```

From src/app/api/inspections/[id]/finalize/route.ts:
```typescript
// Current: POST /api/inspections/[id]/finalize
// Accepts optional { pdfPath } body
// Transitions in_review -> completed
// Admin-only, atomic WHERE guard
```

From src/app/api/inspections/[id]/route.ts (PATCH):
```typescript
// PATCH /api/inspections/[id]
// Auto-save: updates formData + denormalized facility fields
// Status guard: only allows edits to "draft" inspections
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema migration and Drizzle schema updates</name>
  <files>
    src/lib/db/schema.ts
    src/lib/db/migrations/0005_delivery_dashboard.sql
    src/app/api/inspections/[id]/route.ts
  </files>
  <action>
    **Migration SQL** (`0005_delivery_dashboard.sql`):
    Add two columns to the inspections table:
    ```sql
    ALTER TABLE public.inspections
      ADD COLUMN IF NOT EXISTS customer_email text,
      ADD COLUMN IF NOT EXISTS customer_name text;
    ```

    Create the inspection_emails table for email send history tracking:
    ```sql
    CREATE TABLE IF NOT EXISTS public.inspection_emails (
      id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
      inspection_id uuid NOT NULL REFERENCES public.inspections(id) ON DELETE CASCADE,
      recipient_email text NOT NULL,
      subject text NOT NULL,
      sent_at timestamptz DEFAULT now() NOT NULL,
      sent_by uuid REFERENCES public.profiles(id)
    );

    ALTER TABLE public.inspection_emails ENABLE ROW LEVEL SECURITY;

    CREATE POLICY "Authenticated users can view email history"
      ON public.inspection_emails FOR SELECT
      TO authenticated
      USING (true);

    CREATE POLICY "Authenticated users can insert email records"
      ON public.inspection_emails FOR INSERT
      TO authenticated
      WITH CHECK (true);
    ```

    **Drizzle schema updates** (`src/lib/db/schema.ts`):
    1. Add `customerEmail: text("customer_email")` and `customerName: text("customer_name")` columns to the `inspections` table definition, after `facilityZip`.

    2. Add a new `inspectionEmails` table:
    ```typescript
    export const inspectionEmails = pgTable("inspection_emails", {
      id: uuid("id").defaultRandom().primaryKey(),
      inspectionId: uuid("inspection_id")
        .references(() => inspections.id, { onDelete: "cascade" })
        .notNull(),
      recipientEmail: text("recipient_email").notNull(),
      subject: text("subject").notNull(),
      sentAt: timestamp("sent_at").defaultNow().notNull(),
      sentBy: uuid("sent_by").references(() => profiles.id),
    });
    ```

    3. Add relations for `inspectionEmails`:
    ```typescript
    export const inspectionEmailsRelations = relations(inspectionEmails, ({ one }) => ({
      inspection: one(inspections, {
        fields: [inspectionEmails.inspectionId],
        references: [inspections.id],
      }),
      sender: one(profiles, {
        fields: [inspectionEmails.sentBy],
        references: [profiles.id],
      }),
    }));
    ```

    4. Update `inspectionsRelations` to add `emails: many(inspectionEmails)`.

    **PATCH route update** (`src/app/api/inspections/[id]/route.ts`):
    In the existing PATCH handler, after the current denormalized field sync (facilityName, facilityAddress, etc.), also sync `customerName` from `formData.facilityInfo.sellerName` if present. This populates the denormalized column on every auto-save. Do NOT touch `customerEmail` here -- that is set during email send flow.

    Example addition to the PATCH set clause:
    ```typescript
    customerName: facilityInfo?.sellerName ?? null,
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify schema types compile without errors. Verify the migration SQL file exists and contains both ALTER TABLE and CREATE TABLE statements. Check that `inspectionEmails` is exported from schema.ts.
  </verify>
  <done>
    Migration SQL creates customer_email, customer_name columns on inspections and inspection_emails table with RLS policies. Drizzle schema matches SQL. PATCH route syncs customerName from formData on auto-save.
  </done>
</task>

<task type="auto">
  <name>Task 2: PDF storage helpers, finalize route with server-side PDF generation, and download endpoint</name>
  <files>
    src/lib/storage/pdf-storage.ts
    src/app/api/inspections/[id]/finalize/route.ts
    src/app/api/inspections/[id]/download/route.ts
  </files>
  <action>
    **PDF storage helpers** (`src/lib/storage/pdf-storage.ts`):
    Create two utility functions using the existing `createAdminClient` from `@/lib/supabase/admin`:

    1. `uploadReport(inspectionId: string, pdfData: Uint8Array, filename: string): Promise<string>` -- Uploads PDF to `inspection-media` bucket at path `reports/{inspectionId}/{filename}` with `contentType: "application/pdf"` and `upsert: true` (replaces old PDF on re-finalize per CONTEXT.md). Returns the storage path string. Throws on error.

    2. `getReportDownloadUrl(storagePath: string, downloadFilename: string): Promise<string>` -- Creates a signed URL (1 hour expiry) from the `inspection-media` bucket with the `download` option set to `downloadFilename` to trigger browser download with the correct filename. Returns the signed URL. Throws on error.

    3. `buildDownloadFilename(facilityAddress: string | null, completedAt: Date | null): string` -- Builds the address + date filename per CONTEXT.md (e.g., "123-Main-St_2026-02-26.pdf"). Sanitize the address by replacing spaces with hyphens, removing special characters. Use completedAt date or current date. Always append ".pdf".

    **Update finalize route** (`src/app/api/inspections/[id]/finalize/route.ts`):
    Replace the current implementation with server-side PDF generation and storage upload:

    1. Keep existing auth check and admin-only guard (unchanged).
    2. After verifying admin role, load the full inspection record (including formData and media records) from the database. Use `eq(inspections.id, id)` for the inspection and `eq(inspectionMedia.inspectionId, id)` for media.
    3. Cast formData to `InspectionFormData`. If formData is null, return 400 error.
    4. Call `generateReport(formData, null, mediaRecords)` to generate the PDF server-side. Pass `null` for signature since it is already embedded in formData from the client-side generation. Note: The signature data URL is stored in `formData.disposalWorks.signatureDataUrl` if it exists -- extract it and pass it instead of null.
    5. Build the download filename using `buildDownloadFilename(inspection.facilityAddress, new Date())`.
    6. Call `uploadReport(id, pdfData, "report.pdf")` to save to storage. The deterministic path `reports/{id}/report.pdf` ensures upsert replaces on re-finalize.
    7. Perform the atomic status transition (in_review -> completed) with `finalizedPdfPath` set to the returned storage path, `completedAt` to now, and `reviewedBy` to user.id.
    8. Return `{ status: "completed", pdfPath: storagePath }`.

    IMPORTANT: If `generateReport` fails (e.g., font loading issues server-side), catch the error and return 500 with message "PDF generation failed: {error.message}". Do NOT transition status if PDF generation fails. Log the error with `console.error`.

    Import pattern:
    ```typescript
    import { generateReport } from "@/lib/pdf/generate-report";
    import { uploadReport, buildDownloadFilename } from "@/lib/storage/pdf-storage";
    import { inspections, inspectionMedia } from "@/lib/db/schema";
    import type { InspectionFormData } from "@/types/inspection";
    ```

    **Download endpoint** (`src/app/api/inspections/[id]/download/route.ts`):
    Create a GET handler:

    1. Auth check -- require authenticated user (same pattern as existing routes).
    2. Load inspection by id. If not found, return 404.
    3. If `finalizedPdfPath` is null, return 404 with `{ error: "No finalized PDF available" }`.
    4. Build the download filename using `buildDownloadFilename(inspection.facilityAddress, inspection.completedAt)`.
    5. Call `getReportDownloadUrl(inspection.finalizedPdfPath, downloadFilename)` to get a signed URL.
    6. Return `{ downloadUrl: signedUrl, filename: downloadFilename }`.

    Role check: Any authenticated user can download (field techs should see their own completed inspections). The existing RLS policies handle row-level access.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify all files compile. Verify `src/lib/storage/pdf-storage.ts` exports `uploadReport`, `getReportDownloadUrl`, and `buildDownloadFilename`. Verify `/api/inspections/[id]/download/route.ts` exports `GET`. Verify finalize route imports and calls `generateReport` and `uploadReport`.
  </verify>
  <done>
    Finalize route generates PDF server-side and uploads to Supabase Storage. Re-finalize replaces old PDF via upsert. Download endpoint returns signed URL with address+date filename. Storage path stored in `finalizedPdfPath` column.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. Migration SQL file contains ALTER TABLE for customer_email/customer_name and CREATE TABLE for inspection_emails
3. Drizzle schema exports inspectionEmails table with relations
4. pdf-storage.ts exports uploadReport, getReportDownloadUrl, buildDownloadFilename
5. Finalize route calls generateReport server-side then uploadReport
6. Download route returns signed URL with correct filename format
7. PATCH route syncs customerName from formData.facilityInfo.sellerName
</verification>

<success_criteria>
- Database schema includes customer_email, customer_name on inspections and inspection_emails table
- Finalized PDFs are stored in Supabase Storage at `reports/{inspectionId}/report.pdf`
- Re-finalizing replaces old PDF (upsert: true)
- Download endpoint returns a signed URL that triggers browser download with address+date filename
- PATCH auto-save syncs customerName for dashboard search
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-and-dashboard/05-01-SUMMARY.md`
</output>
