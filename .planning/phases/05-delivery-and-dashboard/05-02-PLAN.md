---
phase: 05-delivery-and-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/app/api/inspections/[id]/send-email/route.ts
  - src/app/api/inspections/[id]/emails/route.ts
  - src/components/dashboard/send-email-dialog.tsx
  - src/app/(dashboard)/inspections/[id]/page.tsx
  - src/app/(dashboard)/inspections/[id]/inspection-pdf-view.tsx
  - src/components/review/review-actions.tsx
autonomous: true
requirements: [DLVR-02]

must_haves:
  truths:
    - "Dan can click Send to Customer on a completed inspection and a confirmation dialog opens"
    - "Confirmation dialog shows editable recipient email, subject line, optional personal note, and a preview of the email body"
    - "Recipient email is pre-filled from the inspection's customer_email if available"
    - "After confirming send, the PDF is emailed as an attachment and a success toast appears"
    - "Dan can view send history showing when emails were sent and to whom"
    - "Emails are never sent automatically -- always requires explicit button click + confirmation"
  artifacts:
    - path: "src/app/api/inspections/[id]/send-email/route.ts"
      provides: "POST endpoint that downloads PDF from storage, emails it via Resend, records send history"
      exports: ["POST"]
    - path: "src/app/api/inspections/[id]/emails/route.ts"
      provides: "GET endpoint returning email send history for an inspection"
      exports: ["GET"]
    - path: "src/components/dashboard/send-email-dialog.tsx"
      provides: "SendEmailDialog component with recipient, subject, note fields and preview"
      exports: ["SendEmailDialog"]
    - path: "src/components/review/review-actions.tsx"
      provides: "Updated with Send to Customer button for completed inspections"
      contains: "SendEmailDialog"
  key_links:
    - from: "src/components/dashboard/send-email-dialog.tsx"
      to: "/api/inspections/[id]/send-email"
      via: "fetch POST on confirm"
      pattern: "fetch.*send-email"
    - from: "src/components/dashboard/send-email-dialog.tsx"
      to: "/api/inspections/[id]/emails"
      via: "fetch GET for send history"
      pattern: "fetch.*emails"
    - from: "src/app/api/inspections/[id]/send-email/route.ts"
      to: "src/lib/storage/pdf-storage.ts"
      via: "downloads PDF from storage for attachment"
      pattern: "createAdminClient.*download"
---

<objective>
Add manual email delivery of finalized PDF reports to customers with send history tracking.

Purpose: Dan can send completed inspection reports to customers by clicking a button, confirming the recipient, and optionally adding a personal note. The PDF is attached to the email. Send history is tracked so Dan can see when and to whom reports were sent.

Output: Send-email API route with Resend attachment, email history API, SendEmailDialog component, Send to Customer button on review/detail pages.
</objective>

<execution_context>
@/Users/danielendres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielendres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-and-dashboard/05-RESEARCH.md
@.planning/phases/05-delivery-and-dashboard/05-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 05-01 and existing code. -->

From src/lib/storage/pdf-storage.ts (created in 05-01):
```typescript
export async function uploadReport(inspectionId: string, pdfData: Uint8Array, filename: string): Promise<string>;
export async function getReportDownloadUrl(storagePath: string, downloadFilename: string): Promise<string>;
export async function buildDownloadFilename(facilityAddress: string | null, completedAt: Date | null): string;
```

From src/lib/db/schema.ts (updated in 05-01):
```typescript
export const inspectionEmails = pgTable("inspection_emails", {
  id: uuid("id").defaultRandom().primaryKey(),
  inspectionId: uuid("inspection_id").references(() => inspections.id, { onDelete: "cascade" }).notNull(),
  recipientEmail: text("recipient_email").notNull(),
  subject: text("subject").notNull(),
  sentAt: timestamp("sent_at").defaultNow().notNull(),
  sentBy: uuid("sent_by").references(() => profiles.id),
});

// On inspections table:
// customerEmail: text("customer_email")
// customerName: text("customer_name")
// finalizedPdfPath: text("finalized_pdf_path")
```

From src/lib/supabase/admin.ts:
```typescript
export function createAdminClient(): SupabaseClient;
```

From src/lib/email/send-notification.ts:
```typescript
// Existing pattern: Resend client initialized with env var check
const resend = process.env.RESEND_API_KEY ? new Resend(process.env.RESEND_API_KEY) : null;
```

From src/components/review/review-actions.tsx:
```typescript
// Existing: Finalize, Return, Reopen action buttons for review workflow
// Has inspection prop with id, status, facilityName, etc.
```

From src/app/(dashboard)/inspections/[id]/inspection-pdf-view.tsx:
```typescript
// Client component for inspection detail with PDF generation and preview
// Has inspection and media props
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Email send API route and email history endpoint</name>
  <files>
    src/app/api/inspections/[id]/send-email/route.ts
    src/app/api/inspections/[id]/emails/route.ts
  </files>
  <action>
    **Send-email route** (`src/app/api/inspections/[id]/send-email/route.ts`):
    Create a POST handler:

    1. Auth check: require authenticated user. Decode JWT role -- admin or office_staff only. Return 403 otherwise.
    2. Parse body: `{ recipientEmail: string, subject: string, personalNote?: string }`. Validate recipientEmail is non-empty and contains "@". Return 400 if invalid.
    3. Load inspection by id. If not found, return 404. If `finalizedPdfPath` is null, return 400 with `{ error: "No finalized PDF to send. Please finalize the inspection first." }`.
    4. Download PDF from Supabase Storage using the admin client: `admin.storage.from("inspection-media").download(inspection.finalizedPdfPath)`. The result is a Blob. Convert to Buffer: `Buffer.from(await blob.arrayBuffer())`.
    5. Check buffer size: if base64 size (buffer.length * 4/3) exceeds 35MB, return 400 with `{ error: "PDF too large for email (>35MB). Please download and send manually." }`.
    6. Build the download filename using `buildDownloadFilename(inspection.facilityAddress, inspection.completedAt)`.
    7. Compose email body text:
       ```
       Dear Customer,

       Please find attached your inspection report for {inspection.facilityAddress || "the inspected property"}.

       {personalNote ? personalNote + "\n\n" : ""}If you have any questions about this report, please don't hesitate to contact us.

       Best regards,
       SewerTime Septic
       ```
    8. Send via Resend with attachment:
       ```typescript
       const resend = new Resend(process.env.RESEND_API_KEY!);
       await resend.emails.send({
         from: `SewerTime Inspections <${process.env.EMAIL_FROM_ADDRESS || "onboarding@resend.dev"}>`,
         to: [recipientEmail],
         subject,
         text: emailBody,
         attachments: [{
           content: buffer.toString("base64"),
           filename: downloadFilename,
         }],
       });
       ```
       Use `EMAIL_FROM_ADDRESS` env var so sender is configurable without code changes (falls back to test sender).
    9. Record send history: INSERT into `inspectionEmails` table with `inspectionId`, `recipientEmail`, `subject`, `sentBy: user.id`.
    10. Update `customerEmail` on the inspection if it differs from current value (persist for future pre-fill):
        ```typescript
        await db.update(inspections)
          .set({ customerEmail: recipientEmail, updatedAt: new Date() })
          .where(eq(inspections.id, id));
        ```
    11. Return `{ success: true, sentAt: new Date().toISOString() }`.
    12. If Resend send fails, return 500 with `{ error: "Failed to send email: {message}" }`. Do NOT record history if send fails.

    **Email history route** (`src/app/api/inspections/[id]/emails/route.ts`):
    Create a GET handler:

    1. Auth check: require authenticated user.
    2. Query `inspectionEmails` table filtered by `inspectionId = id`, ordered by `sentAt` descending.
    3. Join with `profiles` to get `sentBy` name: select `inspectionEmails.*` + `profiles.fullName as senderName`.
    4. Return JSON array: `[{ id, recipientEmail, subject, sentAt, senderName }]`.
  </action>
  <verify>
    Run `npx tsc --noEmit`. Verify send-email route exports POST. Verify emails route exports GET. Check that send-email route imports from `@/lib/storage/pdf-storage` and uses Resend. Check that it inserts into inspectionEmails table.
  </verify>
  <done>
    POST /api/inspections/[id]/send-email downloads PDF from storage, sends via Resend with attachment, records in inspection_emails, and persists customerEmail. GET /api/inspections/[id]/emails returns send history with sender names.
  </done>
</task>

<task type="auto">
  <name>Task 2: Send email dialog component and integration into review/detail pages</name>
  <files>
    src/components/dashboard/send-email-dialog.tsx
    src/components/review/review-actions.tsx
    src/app/(dashboard)/inspections/[id]/inspection-pdf-view.tsx
    src/app/(dashboard)/inspections/[id]/page.tsx
  </files>
  <action>
    **SendEmailDialog component** (`src/components/dashboard/send-email-dialog.tsx`):
    Create a "use client" component that renders as an AlertDialog (per CONTEXT.md: confirmation dialog, not full compose screen):

    Props:
    ```typescript
    interface SendEmailDialogProps {
      inspectionId: string;
      facilityAddress: string | null;
      customerEmail: string | null;
      open: boolean;
      onOpenChange: (open: boolean) => void;
    }
    ```

    UI Structure:
    1. AlertDialog with AlertDialogContent.
    2. Title: "Send Report to Customer"
    3. Form fields:
       - **Recipient Email** (Input, required): pre-filled from `customerEmail` prop, always editable. Label: "Recipient Email".
       - **Subject** (Input): default value: `"Inspection Report - {facilityAddress || 'Property Inspection'}"`. Editable.
       - **Personal Note** (Textarea, optional): placeholder "Add a personal note (optional)". 3 rows.
    4. **Email Preview** section below the form fields: a bordered div showing the composed email body text (same template as API route). Updates live as personal note is edited.
    5. **Send History** section: on dialog open, fetch GET `/api/inspections/{inspectionId}/emails`. If entries exist, show a small list: "Previously sent: {date} to {email}" for each, in muted text below the preview. If no entries, hide this section.
    6. Footer buttons: "Cancel" (AlertDialogCancel) and "Send Email" (AlertDialogAction).
    7. On "Send Email" click: POST to `/api/inspections/{inspectionId}/send-email` with `{ recipientEmail, subject, personalNote }`. Show loading state on button. On success, toast "Report sent successfully to {email}" via sonner. On error, toast error message. Close dialog on success.
    8. Disable "Send Email" if recipientEmail is empty or doesn't contain "@".

    **Update ReviewActions** (`src/components/review/review-actions.tsx`):
    Add a "Send to Customer" button for completed inspections. This button:
    - Only renders when `inspection.status === "completed"` or `inspection.status === "sent"`.
    - Uses the Mail icon from lucide-react.
    - Opens the SendEmailDialog.
    - Pass `inspection.customerEmail` (add this to the props interface -- it will come from the server page).

    Update the ReviewActions props interface to include `customerEmail: string | null`.

    **Update review detail page** (`src/app/(dashboard)/review/[id]/page.tsx`):
    The server component should pass `customerEmail` to the ReviewEditor, which passes it to ReviewActions. However, since review-actions.tsx is already a deeply nested client component, the simplest approach is to add `customerEmail` to the inspection prop passed from the review page server component.

    Since this plan only touches inspection-pdf-view.tsx and review-actions.tsx (not the review page.tsx), add `customerEmail` to the existing inspection data flow. If the review page already passes inspection data, ensure customerEmail is included.

    **Update InspectionPdfView** (`src/app/(dashboard)/inspections/[id]/inspection-pdf-view.tsx`):
    Add a "Send to Customer" button alongside the existing download/view controls for completed inspections. This button opens SendEmailDialog. Also add a download button that fetches from `/api/inspections/{inspectionId}/download` and opens the signed URL.

    **Update inspection detail page** (`src/app/(dashboard)/inspections/[id]/page.tsx`):
    Pass `customerEmail` from the loaded inspection to the client component. Add `customerEmail: inspection.customerEmail ?? null` to the props.

    Import the SendEmailDialog in both review-actions.tsx and inspection-pdf-view.tsx.
  </action>
  <verify>
    Run `npx tsc --noEmit`. Verify SendEmailDialog is exported from the new file. Verify review-actions.tsx imports and renders SendEmailDialog. Verify inspection-pdf-view.tsx has both Send and Download buttons for completed inspections.
  </verify>
  <done>
    Send to Customer button appears on completed inspections in both review and detail pages. Clicking opens dialog with pre-filled email, editable subject, optional note, email preview, and send history. Confirming sends the PDF via Resend and records history. Never automatic -- always requires click + confirmation per CONTEXT.md.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Send-email POST route downloads PDF from storage, attaches to Resend email, records in inspection_emails
3. Emails GET route returns send history with sender names
4. SendEmailDialog shows recipient, subject, note, preview, and history
5. Send button appears only for completed/sent inspections
6. Email is never sent automatically -- explicit button + confirmation dialog required
7. customerEmail persisted on inspection after send for future pre-fill
</verification>

<success_criteria>
- Dan can send a completed PDF to any email address via one-click + confirmation
- Dialog pre-fills recipient from inspection record when available
- Email includes PDF attachment with address+date filename
- Send history visible in dialog showing past sends
- No automatic email sending -- always manual trigger per CONTEXT.md decision
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-and-dashboard/05-02-SUMMARY.md`
</output>
