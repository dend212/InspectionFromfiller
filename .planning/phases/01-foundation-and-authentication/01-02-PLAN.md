---
phase: 01-foundation-and-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/db/migrations/*
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/reset-password/page.tsx
  - src/app/(auth)/auth/confirm/route.ts
  - src/app/(auth)/layout.tsx
  - src/app/api/admin/users/route.ts
  - src/components/auth/login-form.tsx
  - src/components/auth/reset-password-form.tsx
  - src/lib/validators/auth.ts
autonomous: false
requirements:
  - AUTH-01
  - AUTH-02
  - WKFL-03

user_setup:
  - service: supabase
    why: "Enable Custom Access Token Auth Hook and push database schema"
    env_vars: []
    dashboard_config:
      - task: "After running db:push, go to Authentication -> Hooks (Beta) -> Custom Access Token and select the custom_access_token_hook function"
        location: "Supabase Dashboard -> Authentication -> Hooks"
      - task: "Disable email confirmations for admin-created users: Authentication -> Providers -> Email -> uncheck 'Confirm email'"
        location: "Supabase Dashboard -> Authentication -> Providers -> Email"

must_haves:
  truths:
    - "User can log in with email and password and reach the dashboard"
    - "User with invalid credentials sees an error message"
    - "User can request a password reset email"
    - "Admin can create a new user account with an assigned role"
    - "The JWT contains a user_role claim after login"
    - "RLS policies restrict data access based on user role"
    - "Field techs can only see their own inspections in the database"
    - "Unauthenticated users are redirected to the login page"
  artifacts:
    - path: "src/app/(auth)/login/page.tsx"
      provides: "SewerTime branded login page"
      min_lines: 10
    - path: "src/components/auth/login-form.tsx"
      provides: "Login form component with email/password fields and error handling"
      exports: ["LoginForm"]
    - path: "src/app/api/admin/users/route.ts"
      provides: "Admin-only API endpoint for creating user accounts"
      exports: ["POST"]
    - path: "src/lib/validators/auth.ts"
      provides: "Zod validation schemas for auth forms"
      exports: ["loginSchema", "createUserSchema"]
    - path: "src/app/(auth)/reset-password/page.tsx"
      provides: "Password reset request page"
      min_lines: 10
    - path: "src/app/(auth)/auth/confirm/route.ts"
      provides: "Email confirmation callback handler"
      exports: ["GET"]
  key_links:
    - from: "src/components/auth/login-form.tsx"
      to: "src/lib/supabase/client.ts"
      via: "createClient() for signInWithPassword"
      pattern: "signInWithPassword"
    - from: "src/app/api/admin/users/route.ts"
      to: "src/lib/supabase/admin.ts"
      via: "createAdminClient() for auth.admin.createUser"
      pattern: "admin\\.createUser"
    - from: "src/app/api/admin/users/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "createClient() for auth check (verify caller is admin)"
      pattern: "getUser|user_role.*admin"
    - from: "custom_access_token_hook (SQL)"
      to: "user_roles table"
      via: "JWT claim injection from role lookup"
      pattern: "user_role"
---

<objective>
Implement the complete authentication flow: SewerTime-branded login page, password reset, admin user creation endpoint, database schema deployment with RLS policies, and the Custom Access Token Auth Hook that injects roles into JWTs.

Purpose: This plan delivers the core auth experience -- users can log in, roles are enforced at the database level, and admin (Dan) can create new user accounts. Without this, no role-based access control exists.

Output: Working login flow, password reset, admin user creation API, deployed database schema with RLS, and role-injected JWTs.
</objective>

<execution_context>
@/Users/danielendres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielendres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-and-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Deploy database schema, RLS policies, and Custom Access Token Hook</name>
  <files>
    src/lib/db/migrations/*
  </files>
  <action>
    **Step 1: Push the Drizzle schema to Supabase.**
    Run `npm run db:push` to deploy the schema defined in `src/lib/db/schema.ts` (profiles, userRoles, inspections, inspectionMedia tables with enums). This creates all tables in the Supabase Postgres database.

    **Step 2: Create the Custom Access Token Auth Hook.**
    Connect to the Supabase SQL Editor (via Supabase Dashboard or `npx supabase` CLI if available) and run the following SQL. Alternatively, create a migration file at `src/lib/db/migrations/0001_custom_auth_hook.sql` and run it manually via the SQL Editor.

    The SQL must:
    1. Create the `custom_access_token_hook` function (PL/pgSQL, STABLE) that:
       - Accepts event jsonb
       - Looks up the user's role from `public.user_roles` by `user_id`
       - Sets `claims.user_role` to the found role (or null if no role)
       - Returns the modified event
    2. Grant permissions:
       - `GRANT USAGE ON SCHEMA public TO supabase_auth_admin`
       - `GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin`
       - `REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public`
       - `GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin`
    3. Create RLS policy for auth admin to read user_roles:
       - `CREATE POLICY "Allow auth admin to read user roles" ON public.user_roles AS PERMISSIVE FOR SELECT TO supabase_auth_admin USING (true)`

    Use the exact SQL from RESEARCH.md Pattern 2.

    **Step 3: Create RLS policies for all tables.**
    Enable RLS on all tables: `ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY`, same for `inspections`, `inspection_media`, `user_roles`.

    Create these policies (from RESEARCH.md Pattern 3):

    **profiles:**
    - SELECT: Users can read their own profile OR admin/office_staff can read all
    - UPDATE: Users can update their own profile

    **inspections:**
    - SELECT: Admin/office_staff see all; field_tech sees only own (where inspector_id = auth.uid())
    - INSERT: Admin/field_tech can create, must set inspector_id = auth.uid()
    - UPDATE: Admin/office_staff can update any; field_tech can update own drafts only

    **inspection_media:**
    - SELECT: Same visibility as parent inspection (join to inspections table)
    - INSERT: Same as inspection INSERT permissions
    - DELETE: Admin/office_staff can delete any; field_tech can delete from own inspections

    **user_roles:**
    - ALL: Only admin can manage (`auth.jwt() ->> 'user_role' = 'admin'`)
    - PLUS: The supabase_auth_admin policy from Step 2

    **Step 4: Create a seed SQL to insert Dan's profile and admin role.**
    Create a SQL snippet (document in SUMMARY, not a committed file) that:
    1. After Dan creates his Supabase auth account, inserts a matching `profiles` row
    2. Inserts a `user_roles` row with role = 'admin'
    This will be run once manually after Dan's first login.

    **IMPORTANT:** All SQL that cannot be expressed via Drizzle schema (RLS policies, functions, grants) should be placed in a `.sql` file in `src/lib/db/migrations/` for reference, even if applied manually via the SQL Editor. This ensures the SQL is version-controlled.
  </action>
  <verify>
    <automated>cd "/Users/danielendres/Documents/Dans Stuff/Inspection Form Filler" && npm run db:push 2>&1 | tail -10</automated>
    Verify tables exist in Supabase Dashboard -> Table Editor. Verify the custom_access_token_hook function exists in Database -> Functions.
  </verify>
  <done>
    - All 4 tables (profiles, user_roles, inspections, inspection_media) exist in Supabase
    - Both enums (app_role, inspection_status) exist
    - RLS is enabled on all tables with correct policies
    - custom_access_token_hook function is created and permissions are granted
    - Migration/seed SQL files are version-controlled in src/lib/db/migrations/
  </done>
</task>

<task type="auto">
  <name>Task 2: Build login page, password reset, admin user creation API, and Zod validators</name>
  <files>
    src/app/(auth)/login/page.tsx
    src/app/(auth)/reset-password/page.tsx
    src/app/(auth)/auth/confirm/route.ts
    src/app/(auth)/layout.tsx
    src/app/api/admin/users/route.ts
    src/components/auth/login-form.tsx
    src/components/auth/reset-password-form.tsx
    src/lib/validators/auth.ts
  </files>
  <action>
    **Step 1: Create Zod validation schemas.**
    Create `src/lib/validators/auth.ts` with:
    - `loginSchema`: z.object with email (z.string().email()) and password (z.string().min(1, "Password is required"))
    - `createUserSchema`: z.object with email (z.string().email()), password (z.string().min(8, "Password must be at least 8 characters")), fullName (z.string().min(1, "Name is required")), role (z.enum(["admin", "field_tech", "office_staff"]))

    **Step 2: Create the auth route group layout.**
    Create `src/app/(auth)/layout.tsx` -- minimal layout with no navigation. Center content vertically and horizontally. Light background. This wraps login and reset-password pages.

    **Step 3: Build the login form component.**
    Create `src/components/auth/login-form.tsx` as a client component ('use client'). Implementation:
    - Use shadcn/ui Card, CardHeader, CardTitle, CardContent, Button, Input, Label
    - SewerTime branding: Display "SewerTime Septic" as the card title. Use a professional color scheme (the exact colors are at Claude's discretion, but should feel business-like, not generic). Include a subtitle "Inspection Management" or similar.
    - Form fields: email (type="email", required), password (type="password", required)
    - On submit: call `supabase.auth.signInWithPassword({ email, password })` using the browser client from `src/lib/supabase/client.ts`
    - On success: `router.push('/')` then `router.refresh()`
    - On error: display error message in red text below the form
    - Loading state: disable button and show "Signing in..." text while authenticating
    - Link to password reset page below the form: "Forgot your password?"
    - Validate with loginSchema before submitting (client-side Zod validation)

    **Step 4: Create the login page.**
    Create `src/app/(auth)/login/page.tsx` as a server component. Render the LoginForm component. If user is already logged in (check via server-side `supabase.auth.getUser()`), redirect to `/`.

    **Step 5: Build the password reset form component.**
    Create `src/components/auth/reset-password-form.tsx` as a client component. Implementation:
    - Card layout similar to login
    - Single email field
    - On submit: call `supabase.auth.resetPasswordForEmail(email, { redirectTo: \`\${window.location.origin}/auth/confirm?next=/reset-password\` })`
    - Show success message: "Check your email for a reset link"
    - Link back to login page

    **Step 6: Create the password reset page.**
    Create `src/app/(auth)/reset-password/page.tsx` rendering the ResetPasswordForm.

    **Step 7: Create the email confirmation callback.**
    Create `src/app/(auth)/auth/confirm/route.ts` as a GET route handler:
    - Extract `token_hash` and `type` from URL search params
    - If present, call `supabase.auth.verifyOtp({ token_hash, type })`
    - Read `next` param for redirect destination (default to `/`)
    - Redirect to the `next` URL on success, or to `/login?error=confirmation_failed` on failure

    **Step 8: Build the admin user creation API.**
    Create `src/app/api/admin/users/route.ts` as a POST route handler:
    - Verify caller is authenticated: `const supabase = await createClient()`, `const { data: { user } } = await supabase.auth.getUser()`. If no user, return 401.
    - Verify caller is admin: decode JWT or use `getUser()` metadata. Check that the caller's role is 'admin'. Use jwt-decode on the session access token or query the user_roles table. If not admin, return 403.
    - Parse request body with `createUserSchema`
    - Create user via `createAdminClient().auth.admin.createUser({ email, password, email_confirm: true, user_metadata: { full_name: fullName } })`
    - Insert profile row in `profiles` table (id = new user's id, fullName, email)
    - Insert role in `user_roles` table (userId = new user's id, role)
    - Return the created user object on success (201)
    - Return error details on failure (400)

    **IMPORTANT decisions honored (from CONTEXT.md):**
    - Dan creates all accounts -- no self-signup. There is NO /signup page. The login page has no "Create account" link.
    - SewerTime branded login -- professional look, company name prominent
    - Persistent sessions -- Supabase default behavior, no custom session expiry
    - Self-service password reset via email -- the reset-password page handles this
  </action>
  <verify>
    <automated>cd "/Users/danielendres/Documents/Dans Stuff/Inspection Form Filler" && npm run build 2>&1 | tail -20</automated>
    Also verify: Login page renders at /login. Reset password page renders at /reset-password. API route exists at /api/admin/users.
  </verify>
  <done>
    - Login page at /login renders with SewerTime branding, email/password fields, and forgot password link
    - Reset password page at /reset-password renders with email field and success message
    - Auth confirmation route handles OTP verification at /auth/confirm
    - Admin user creation API at /api/admin/users accepts POST with email, password, fullName, role
    - Admin API rejects non-admin callers with 403
    - Zod validators exist for login and user creation forms
    - No self-signup anywhere in the app
    - Build completes without errors
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 3: Enable Custom Access Token Hook in Supabase Dashboard and create Dan's admin account</name>
  <action>Configure Supabase dashboard settings that require manual UI interaction</action>
  <instructions>
    **Part A: Enable the Custom Access Token Hook**
    1. Go to Supabase Dashboard -> Authentication -> Hooks (Beta)
    2. Find "Custom Access Token" hook
    3. Enable it and select the `custom_access_token_hook` function from the dropdown
    4. Save

    **Part B: Create Dan's admin account**
    1. Go to Supabase Dashboard -> Authentication -> Users
    2. Click "Add user" -> "Create new user"
    3. Enter Dan's email and a password
    4. After creation, note the user's UUID from the Users list
    5. Go to SQL Editor and run:
       ```sql
       INSERT INTO public.profiles (id, full_name, email)
       VALUES ('<dan-user-uuid>', 'Daniel Endres', '<dan-email>');

       INSERT INTO public.user_roles (user_id, role)
       VALUES ('<dan-user-uuid>', 'admin');
       ```
    6. Test: Log in at the deployed Vercel URL with Dan's credentials
    7. After login, open browser DevTools -> Application -> Cookies, find the `sb-*-auth-token` cookie, and decode the JWT at jwt.io. Verify it contains `"user_role": "admin"`.

    **Part C: Verify RLS**
    In the SQL Editor, verify RLS is working by running:
    ```sql
    -- This should return Dan's profile (run as authenticated user)
    SELECT * FROM public.profiles;
    -- This should show Dan's admin role
    SELECT * FROM public.user_roles;
    ```

    Type "done" when the hook is enabled, Dan can log in, and the JWT contains user_role=admin.
  </instructions>
  <resume-signal>Type "done" when Custom Access Token Hook is enabled, Dan's admin account is created, and JWT contains user_role=admin</resume-signal>
</task>

</tasks>

<verification>
- Dan can log in at /login with email and password
- After login, JWT contains `user_role: admin` claim
- Invalid credentials show an error on the login page
- /reset-password page sends a reset email
- POST /api/admin/users creates a new user (when called by admin)
- POST /api/admin/users returns 403 when called by non-admin
- RLS policies are active: field_tech can only query their own inspections
- Unauthenticated users are redirected to /login by proxy.ts
</verification>

<success_criteria>
1. Complete email/password login flow working end-to-end
2. Password reset flow sends email and allows password change
3. Custom Access Token Hook injects user_role into JWT
4. RLS policies enforce role-based data access at database level
5. Admin user creation API works with proper authorization checks
6. Dan's admin account exists and can log in with correct role
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-authentication/01-02-SUMMARY.md`
</output>
